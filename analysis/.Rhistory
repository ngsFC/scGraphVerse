matrix2_binary <- (matrix2 > 0)
intersection_size <- sum(matrix1_binary & matrix2_binary)  # Element-wise AND
union_size <- sum(matrix1_binary | matrix2_binary)  # Element-wise OR
jaccard_index <- intersection_size / union_size
return(jaccard_index)
}
calculate_jaccard_for_all_pairs <- function(adj_matrix_list) {
num_matrices <- length(adj_matrix_list)
jaccard_matrix <- matrix(0, nrow = num_matrices, ncol = num_matrices)
colnames(jaccard_matrix) <- names(adj_matrix_list)
rownames(jaccard_matrix) <- names(adj_matrix_list)
for (i in 1:num_matrices) {
for (j in i:num_matrices) {
jaccard_matrix[i, j] <- calculate_jaccard_index_adj_matrices(adj_matrix_list[[i]], adj_matrix_list[[j]])
jaccard_matrix[j, i] <- jaccard_matrix[i, j]  # Symmetric matrix
}
}
return(jaccard_matrix)
}
jaccard_index_matrix <- calculate_jaccard_for_all_pairs(adj_matrix_list)
jaccard_long <- melt(jaccard_index_matrix)
ggplot(jaccard_long, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0.5, limit = c(0, 1)) +
geom_text(aes(label = round(value, 2)), color = "black") +
theme_minimal() +
labs(title = "Jaccard Index Heatmap of Adjacency Matrices",
x = "Matrix",
y = "Matrix",
fill = "Jaccard Index") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Function to plot graphs with only genes that have at least one edge
plot_non_isolated_genes <- function(adj_matrix_list) {
par(mfrow = c(2, 3))  # Set up a 2x3 grid for plotting the graphs
for (i in seq_along(adj_matrix_list)) {
# Convert adjacency matrix to an igraph object
graph <- graph_from_adjacency_matrix(adj_matrix_list[[i]], mode = "undirected", diag = FALSE)
# Select only the vertices with at least one edge (degree > 0)
non_isolated_vertices <- V(graph)[degree(graph) > 1]
# Create a subgraph with only the non-isolated vertices
subgraph <- induced_subgraph(graph, non_isolated_vertices)
# Plot the subgraph with only non-isolated vertices
plot(subgraph,
main = paste("Graph for Matrix", names(adj_matrix_list)[i]),
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Reset plotting area to default
par(mfrow = c(1, 1))
}
# Assuming 'adj_matrix_list' contains your adjacency matrices, call the function to plot them
plot_non_isolated_genes(adj_matrix_list)
# Function to create a consensus adjacency matrix from a list of matrices
create_consensus_matrix <- function(adj_matrix_list) {
# Sum up all adjacency matrices
consensus_matrix <- Reduce("+", adj_matrix_list)
# Set a threshold to create a consensus matrix (edges that appear in all matrices)
threshold <- length(adj_matrix_list)-2  # All matrices should have this edge
# Create a binary matrix where edges appear in all matrices
consensus_matrix_binary <- consensus_matrix >= threshold
# Set diagonal to zero (no self-loops)
diag(consensus_matrix_binary) <- 1
return(consensus_matrix_binary)
}
# Function to plot a graph with only genes that have at least one edge
plot_non_isolated_consensus <- function(consensus_matrix) {
# Convert consensus matrix to an igraph object
graph <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
# Select only the vertices with at least one edge (degree > 0)
non_isolated_vertices <- V(graph)[degree(graph) > 0]
# Create a subgraph with only the non-isolated vertices
subgraph <- induced_subgraph(graph, non_isolated_vertices)
# Plot the subgraph with only non-isolated vertices
plot(subgraph,
main = "",
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Function to calculate Jaccard index between two adjacency matrices
calculate_jaccard_index_adj_matrices <- function(matrix1, matrix2) {
# Convert matrices to binary (1 if there's an edge, 0 otherwise)
matrix1_binary <- (matrix1 > 0)
matrix2_binary <- (matrix2 > 0)
# Calculate the intersection and union of the binary matrices
intersection_size <- sum(matrix1_binary & matrix2_binary)  # Element-wise AND
union_size <- sum(matrix1_binary | matrix2_binary)  # Element-wise OR
# Compute Jaccard Index
jaccard_index <- intersection_size / union_size
return(jaccard_index)
}
# Step 1: Create the consensus matrix from the original matrices
original_consensus_matrix <- create_consensus_matrix(adj_matrix_list)
# Step 2: Calculate Jaccard index between the consensus matrix and the provided consensus matrix
# Replace `graph_provided_matrix` with your actual provided consensus matrix
# graph_provided_matrix <- matrix(...)  # Load your provided consensus adjacency matrix here
# Calculate Jaccard index for the entire matrix (no filtering)
jaccard_index_entire_matrix <- calculate_jaccard_index_adj_matrices(original_consensus_matrix, adjm)
# Print the Jaccard index for the entire matrix
cat("Jaccard Index :", round(jaccard_index_entire_matrix, 3), "\n")
par(mfrow = c(1, 2))
# Step 3: Plot the consensus graph with only non-isolated genes (for visualization purposes)
plot_non_isolated_consensus(original_consensus_matrix)
plot_non_isolated_consensus(adjm)
par(mfrow = c(1, 1))
# Function to plot the original graph with edges highlighted based on consensus presence
plot_original_with_highlight <- function(original_matrix, consensus_matrix) {
# Convert original and consensus matrices to igraph objects
graph_original <- graph_from_adjacency_matrix(original_matrix, mode = "undirected", diag = FALSE)
graph_consensus <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
# Get edge list for the original graph
original_edges <- as_edgelist(graph_original)
# Get edge list for the consensus graph
consensus_edges <- as_edgelist(graph_consensus)
# Convert edge lists to character format to compare easily
original_edges_set <- apply(original_edges, 1, function(x) paste(sort(x), collapse = "-"))
consensus_edges_set <- apply(consensus_edges, 1, function(x) paste(sort(x), collapse = "-"))
# Assign colors to the edges based on presence in consensus graph
edge_colors <- ifelse(original_edges_set %in% consensus_edges_set, "red", "blue")
# Plot the original graph with colored edges
plot(graph_original,
edge.color = edge_colors,
main = "Original Graph with Consensus Highlight",
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Step 2: Plot the original graph with highlighted consensus edges
# Replace `adjm` with your actual original adjacency matrix
plot_original_with_highlight(adjm, original_consensus_matrix)
# Print the Jaccard index for the entire matrix
cat("Jaccard Index :", round(jaccard_index_entire_matrix, 3), "\n")
adj_matrix_list <- list()
for (name in names(link_list_genie3_list)) {
link_list_genie3 <- link_list_genie3_list[[name]]
gene_names <- unique(c(link_list_genie3$regulator, link_list_genie3$target))
adj_matrix_genie3 <- matrix(0, nrow = length(gene_names), ncol = length(gene_names))
rownames(adj_matrix_genie3) <- colnames(adj_matrix_genie3) <- gene_names
weight_cutoff <- quantile(link_list_genie3$weight, 0.75)  # Adjust this value as needed
weight_distribution_plot <- ggplot(data = link_list_genie3, aes(x = weight)) +
geom_histogram(binwidth = 0.01, fill = "skyblue", color = "black") +
geom_vline(aes(xintercept = weight_cutoff), color = "red", linetype = "dashed", size = 1) +
theme_minimal() +
labs(title = paste("Distribution of Weights for", name),
x = "Weight",
y = "Frequency",
caption = paste("Cut-off point:", round(weight_cutoff, 3))) +
theme(plot.title = element_text(hjust = 0.5)) #+
#xlim(0, 1)  # Adjust x-axis limits as needed
print(weight_distribution_plot)
for (i in 1:nrow(link_list_genie3)) {
regulator <- link_list_genie3$regulator[i]
target <- link_list_genie3$target[i]
weight <- link_list_genie3$weight[i]
if (weight >= weight_cutoff) {
adj_matrix_genie3[regulator, target] <- 1
adj_matrix_genie3[target, regulator] <- 1  # Ensure symmetry
}
}
diag(adj_matrix_genie3) <- 1
adj_matrix_list[[name]] <- adj_matrix_genie3
write.csv(adj_matrix_genie3, paste0("genie3_adjacency_matrix_", name, "_cutoff_", round(weight_cutoff, 2), ".csv"), row.names = TRUE)
}
adj_matrix_list[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GENIE3 adjacency")
calculate_jaccard_index_adj_matrices <- function(matrix1, matrix2) {
# Convert matrices to binary (1 if there's an edge, 0 otherwise)
matrix1_binary <- (matrix1 > 0)
matrix2_binary <- (matrix2 > 0)
intersection_size <- sum(matrix1_binary & matrix2_binary)  # Element-wise AND
union_size <- sum(matrix1_binary | matrix2_binary)  # Element-wise OR
jaccard_index <- intersection_size / union_size
return(jaccard_index)
}
calculate_jaccard_for_all_pairs <- function(adj_matrix_list) {
num_matrices <- length(adj_matrix_list)
jaccard_matrix <- matrix(0, nrow = num_matrices, ncol = num_matrices)
colnames(jaccard_matrix) <- names(adj_matrix_list)
rownames(jaccard_matrix) <- names(adj_matrix_list)
for (i in 1:num_matrices) {
for (j in i:num_matrices) {
jaccard_matrix[i, j] <- calculate_jaccard_index_adj_matrices(adj_matrix_list[[i]], adj_matrix_list[[j]])
jaccard_matrix[j, i] <- jaccard_matrix[i, j]  # Symmetric matrix
}
}
return(jaccard_matrix)
}
jaccard_index_matrix <- calculate_jaccard_for_all_pairs(adj_matrix_list)
jaccard_long <- melt(jaccard_index_matrix)
ggplot(jaccard_long, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0.5, limit = c(0, 1)) +
geom_text(aes(label = round(value, 2)), color = "black") +
theme_minimal() +
labs(title = "Jaccard Index Heatmap of Adjacency Matrices",
x = "Matrix",
y = "Matrix",
fill = "Jaccard Index") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Function to plot graphs with only genes that have at least one edge
plot_non_isolated_genes <- function(adj_matrix_list) {
par(mfrow = c(2, 3))  # Set up a 2x3 grid for plotting the graphs
for (i in seq_along(adj_matrix_list)) {
# Convert adjacency matrix to an igraph object
graph <- graph_from_adjacency_matrix(adj_matrix_list[[i]], mode = "undirected", diag = FALSE)
# Select only the vertices with at least one edge (degree > 0)
non_isolated_vertices <- V(graph)[degree(graph) > 1]
# Create a subgraph with only the non-isolated vertices
subgraph <- induced_subgraph(graph, non_isolated_vertices)
# Plot the subgraph with only non-isolated vertices
plot(subgraph,
main = paste("Graph for Matrix", names(adj_matrix_list)[i]),
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Reset plotting area to default
par(mfrow = c(1, 1))
}
# Assuming 'adj_matrix_list' contains your adjacency matrices, call the function to plot them
plot_non_isolated_genes(adj_matrix_list)
# Function to create a consensus adjacency matrix from a list of matrices
create_consensus_matrix <- function(adj_matrix_list) {
# Sum up all adjacency matrices
consensus_matrix <- Reduce("+", adj_matrix_list)
# Set a threshold to create a consensus matrix (edges that appear in all matrices)
threshold <- length(adj_matrix_list)-2  # All matrices should have this edge
# Create a binary matrix where edges appear in all matrices
consensus_matrix_binary <- consensus_matrix >= threshold
# Set diagonal to zero (no self-loops)
diag(consensus_matrix_binary) <- 1
return(consensus_matrix_binary)
}
# Function to plot a graph with only genes that have at least one edge
plot_non_isolated_consensus <- function(consensus_matrix) {
# Convert consensus matrix to an igraph object
graph <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
# Select only the vertices with at least one edge (degree > 0)
non_isolated_vertices <- V(graph)[degree(graph) > 0]
# Create a subgraph with only the non-isolated vertices
subgraph <- induced_subgraph(graph, non_isolated_vertices)
# Plot the subgraph with only non-isolated vertices
plot(subgraph,
main = "",
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Function to calculate Jaccard index between two adjacency matrices
calculate_jaccard_index_adj_matrices <- function(matrix1, matrix2) {
# Convert matrices to binary (1 if there's an edge, 0 otherwise)
matrix1_binary <- (matrix1 > 0)
matrix2_binary <- (matrix2 > 0)
# Calculate the intersection and union of the binary matrices
intersection_size <- sum(matrix1_binary & matrix2_binary)  # Element-wise AND
union_size <- sum(matrix1_binary | matrix2_binary)  # Element-wise OR
# Compute Jaccard Index
jaccard_index <- intersection_size / union_size
return(jaccard_index)
}
# Step 1: Create the consensus matrix from the original matrices
original_consensus_matrix <- create_consensus_matrix(adj_matrix_list)
# Step 2: Calculate Jaccard index between the consensus matrix and the provided consensus matrix
# Replace `graph_provided_matrix` with your actual provided consensus matrix
# graph_provided_matrix <- matrix(...)  # Load your provided consensus adjacency matrix here
# Calculate Jaccard index for the entire matrix (no filtering)
jaccard_index_entire_matrix <- calculate_jaccard_index_adj_matrices(original_consensus_matrix, adjm)
# Print the Jaccard index for the entire matrix
cat("Jaccard Index :", round(jaccard_index_entire_matrix, 3), "\n")
par(mfrow = c(1, 2))
# Step 3: Plot the consensus graph with only non-isolated genes (for visualization purposes)
plot_non_isolated_consensus(original_consensus_matrix)
plot_non_isolated_consensus(adjm)
par(mfrow = c(1, 1))
# Function to plot the original graph with edges highlighted based on consensus presence
plot_original_with_highlight <- function(original_matrix, consensus_matrix) {
# Convert original and consensus matrices to igraph objects
graph_original <- graph_from_adjacency_matrix(original_matrix, mode = "undirected", diag = FALSE)
graph_consensus <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
# Get edge list for the original graph
original_edges <- as_edgelist(graph_original)
# Get edge list for the consensus graph
consensus_edges <- as_edgelist(graph_consensus)
# Convert edge lists to character format to compare easily
original_edges_set <- apply(original_edges, 1, function(x) paste(sort(x), collapse = "-"))
consensus_edges_set <- apply(consensus_edges, 1, function(x) paste(sort(x), collapse = "-"))
# Assign colors to the edges based on presence in consensus graph
edge_colors <- ifelse(original_edges_set %in% consensus_edges_set, "red", "blue")
# Plot the original graph with colored edges
plot(graph_original,
edge.color = edge_colors,
main = "Original Graph with Consensus Highlight",
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Step 2: Plot the original graph with highlighted consensus edges
# Replace `adjm` with your actual original adjacency matrix
plot_original_with_highlight(adjm, original_consensus_matrix)
# Print the Jaccard index for the entire matrix
cat("Jaccard Index :", round(jaccard_index_entire_matrix, 3), "\n")
# Function to create a consensus adjacency matrix from a list of matrices
create_consensus_matrix <- function(adj_matrix_list) {
# Sum up all adjacency matrices
consensus_matrix <- Reduce("+", adj_matrix_list)
# Set a threshold to create a consensus matrix (edges that appear in all matrices)
threshold <- length(adj_matrix_list)-1  # All matrices should have this edge
# Create a binary matrix where edges appear in all matrices
consensus_matrix_binary <- consensus_matrix >= threshold
# Set diagonal to zero (no self-loops)
diag(consensus_matrix_binary) <- 1
return(consensus_matrix_binary)
}
# Function to plot a graph with only genes that have at least one edge
plot_non_isolated_consensus <- function(consensus_matrix) {
# Convert consensus matrix to an igraph object
graph <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
# Select only the vertices with at least one edge (degree > 0)
non_isolated_vertices <- V(graph)[degree(graph) > 0]
# Create a subgraph with only the non-isolated vertices
subgraph <- induced_subgraph(graph, non_isolated_vertices)
# Plot the subgraph with only non-isolated vertices
plot(subgraph,
main = "",
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Function to calculate Jaccard index between two adjacency matrices
calculate_jaccard_index_adj_matrices <- function(matrix1, matrix2) {
# Convert matrices to binary (1 if there's an edge, 0 otherwise)
matrix1_binary <- (matrix1 > 0)
matrix2_binary <- (matrix2 > 0)
# Calculate the intersection and union of the binary matrices
intersection_size <- sum(matrix1_binary & matrix2_binary)  # Element-wise AND
union_size <- sum(matrix1_binary | matrix2_binary)  # Element-wise OR
# Compute Jaccard Index
jaccard_index <- intersection_size / union_size
return(jaccard_index)
}
# Step 1: Create the consensus matrix from the original matrices
original_consensus_matrix <- create_consensus_matrix(adj_matrix_list)
# Step 2: Calculate Jaccard index between the consensus matrix and the provided consensus matrix
# Replace `graph_provided_matrix` with your actual provided consensus matrix
# graph_provided_matrix <- matrix(...)  # Load your provided consensus adjacency matrix here
# Calculate Jaccard index for the entire matrix (no filtering)
jaccard_index_entire_matrix <- calculate_jaccard_index_adj_matrices(original_consensus_matrix, adjm)
# Print the Jaccard index for the entire matrix
cat("Jaccard Index :", round(jaccard_index_entire_matrix, 3), "\n")
par(mfrow = c(1, 2))
# Step 3: Plot the consensus graph with only non-isolated genes (for visualization purposes)
plot_non_isolated_consensus(original_consensus_matrix)
plot_non_isolated_consensus(adjm)
par(mfrow = c(1, 1))
# Function to plot the original graph with edges highlighted based on consensus presence
plot_original_with_highlight <- function(original_matrix, consensus_matrix) {
# Convert original and consensus matrices to igraph objects
graph_original <- graph_from_adjacency_matrix(original_matrix, mode = "undirected", diag = FALSE)
graph_consensus <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
# Get edge list for the original graph
original_edges <- as_edgelist(graph_original)
# Get edge list for the consensus graph
consensus_edges <- as_edgelist(graph_consensus)
# Convert edge lists to character format to compare easily
original_edges_set <- apply(original_edges, 1, function(x) paste(sort(x), collapse = "-"))
consensus_edges_set <- apply(consensus_edges, 1, function(x) paste(sort(x), collapse = "-"))
# Assign colors to the edges based on presence in consensus graph
edge_colors <- ifelse(original_edges_set %in% consensus_edges_set, "red", "blue")
# Plot the original graph with colored edges
plot(graph_original,
edge.color = edge_colors,
main = "Original Graph with Consensus Highlight",
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Step 2: Plot the original graph with highlighted consensus edges
# Replace `adjm` with your actual original adjacency matrix
plot_original_with_highlight(adjm, original_consensus_matrix)
# Function to create a consensus adjacency matrix from a list of matrices
create_consensus_matrix <- function(adj_matrix_list) {
# Sum up all adjacency matrices
consensus_matrix <- Reduce("+", adj_matrix_list)
# Set a threshold to create a consensus matrix (edges that appear in all matrices)
threshold <- length(adj_matrix_list)-2  # All matrices should have this edge
# Create a binary matrix where edges appear in all matrices
consensus_matrix_binary <- consensus_matrix >= threshold
# Set diagonal to zero (no self-loops)
diag(consensus_matrix_binary) <- 1
return(consensus_matrix_binary)
}
# Function to plot a graph with only genes that have at least one edge
plot_non_isolated_consensus <- function(consensus_matrix) {
# Convert consensus matrix to an igraph object
graph <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
# Select only the vertices with at least one edge (degree > 0)
non_isolated_vertices <- V(graph)[degree(graph) > 0]
# Create a subgraph with only the non-isolated vertices
subgraph <- induced_subgraph(graph, non_isolated_vertices)
# Plot the subgraph with only non-isolated vertices
plot(subgraph,
main = "",
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Function to calculate Jaccard index between two adjacency matrices
calculate_jaccard_index_adj_matrices <- function(matrix1, matrix2) {
# Convert matrices to binary (1 if there's an edge, 0 otherwise)
matrix1_binary <- (matrix1 > 0)
matrix2_binary <- (matrix2 > 0)
# Calculate the intersection and union of the binary matrices
intersection_size <- sum(matrix1_binary & matrix2_binary)  # Element-wise AND
union_size <- sum(matrix1_binary | matrix2_binary)  # Element-wise OR
# Compute Jaccard Index
jaccard_index <- intersection_size / union_size
return(jaccard_index)
}
# Step 1: Create the consensus matrix from the original matrices
original_consensus_matrix <- create_consensus_matrix(adj_matrix_list)
# Step 2: Calculate Jaccard index between the consensus matrix and the provided consensus matrix
# Replace `graph_provided_matrix` with your actual provided consensus matrix
# graph_provided_matrix <- matrix(...)  # Load your provided consensus adjacency matrix here
# Calculate Jaccard index for the entire matrix (no filtering)
jaccard_index_entire_matrix <- calculate_jaccard_index_adj_matrices(original_consensus_matrix, adjm)
# Print the Jaccard index for the entire matrix
cat("Jaccard Index :", round(jaccard_index_entire_matrix, 3), "\n")
par(mfrow = c(1, 2))
# Step 3: Plot the consensus graph with only non-isolated genes (for visualization purposes)
plot_non_isolated_consensus(original_consensus_matrix)
plot_non_isolated_consensus(adjm)
par(mfrow = c(1, 1))
# Function to plot the original graph with edges highlighted based on consensus presence
plot_original_with_highlight <- function(original_matrix, consensus_matrix) {
# Convert original and consensus matrices to igraph objects
graph_original <- graph_from_adjacency_matrix(original_matrix, mode = "undirected", diag = FALSE)
graph_consensus <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
# Get edge list for the original graph
original_edges <- as_edgelist(graph_original)
# Get edge list for the consensus graph
consensus_edges <- as_edgelist(graph_consensus)
# Convert edge lists to character format to compare easily
original_edges_set <- apply(original_edges, 1, function(x) paste(sort(x), collapse = "-"))
consensus_edges_set <- apply(consensus_edges, 1, function(x) paste(sort(x), collapse = "-"))
# Assign colors to the edges based on presence in consensus graph
edge_colors <- ifelse(original_edges_set %in% consensus_edges_set, "red", "blue")
# Plot the original graph with colored edges
plot(graph_original,
edge.color = edge_colors,
main = "Original Graph with Consensus Highlight",
vertex.label.color = "black",
vertex.size = 1,
edge.width = 2,
vertex.label.cex = 0.8,
layout = layout_with_fr)
}
# Step 2: Plot the original graph with highlighted consensus edges
# Replace `adjm` with your actual original adjacency matrix
plot_original_with_highlight(adjm, original_consensus_matrix)
#sudo apt-get install python3-venv
use_python("/usr/bin/python3", required = TRUE)
py_config()
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")
count_matrix_df <- as.data.frame(count_matrices[[1]])
genes <- colnames(count_matrix_df)
df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = genes, index = rownames(count_matrix_df))
grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
grn_links %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GRNBoost2 links")
#sudo apt-get install python3-venv
use_python("/usr/bin/python3", required = TRUE)
py_config()
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")
count_matrix_df <- as.data.frame(count_matrices[[1]])
genes <- colnames(count_matrix_df)
df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = genes, index = rownames(count_matrix_df))
benchmark(grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes))
