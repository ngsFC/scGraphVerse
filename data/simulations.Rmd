---
title: "Simulations Inferred network and Performances"
author: "Francesco Cecere"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    theme: cerulean
    df_print: paged
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

## Load Libraries and data

```{r}
library(RColorBrewer)
library(DT)
library(tidyverse)
library(Seurat)
library(STRINGdb)
library(SingleCellExperiment)
library(NodeVerse)
library(BiocParallel)
library(GENIE3)

reticulate::use_python("/usr/bin/python3", required = TRUE)
arboreto <- reticulate::import("arboreto.algo")
pandas <- reticulate::import("pandas")
numpy <- reticulate::import("numpy")

time <- list()

ddir <- "/home/francescoc/Desktop/NodeVerse/analysis/GENIE3/data"
pdir <- "/home/francescoc/Desktop/NodeVerse/analysis/GENIE3/plots"

adjm <- as.matrix(read.table("./../analysis/adjm_p677.txt"))
colnames(adjm) <- rownames(adjm)
count_matrices <- readRDS("./../analysis/sim_n500p677.RDS")
dim(count_matrices[[1]])

```

## GENIE3

### Late integration

```{r}
set.seed(1234)
time[["GENIE3_late_15Cores"]] <- system.time(
  genie3_late <- infer_networks(count_matrices, 
                                method="GENIE3",
                                nCores = 15)
)

```

#### Symmetrize and ROC

```{r}
genie3_late_wadj <- generate_adjacency(genie3_late)
sgenie3_late_wadj <- symmetrize(genie3_late_wadj, weight_function = "mean")

plotROC(sgenie3_late_wadj, adjm, plot_title = "ROC curve - GENIE3 Late Integration", is_binary = F)
```

#### Cutoff

```{r}
sgenie3_late_adj <- cutoff_adjacency(count_matrices = count_matrices,
                                     weighted_adjm_list = sgenie3_late_wadj, 
                                     n = 3,
                                     method = "GENIE3",
                                     nCores = 15)

pscores(adjm, sgenie3_late_adj)
plotg(sgenie3_late_adj)

```

#### Consensus

```{r}
consesusm <- create_consensus(sgenie3_late_adj, method="vote")
consesusu <- create_consensus(sgenie3_late_adj, method="union")
consesunet <- create_consensus(adj_matrix_list = sgenie3_late_adj, weighted_list = sgenie3_late_wadj, method = "INet", threshold = 0.05, ncores = 15)

pscores(adjm, list(consesusm))
pscores(adjm, list(consesusu))
pscores(adjm, list(consesunet))
```

#### Plot comparison

```{r}
compare_consensus(consesusm, adjm)
compare_consensus(consesusu, adjm)
compare_consensus(consesunet, adjm)
```

### Early integration

```{r}
count_matrices <- lapply(count_matrices, as.matrix)
early_matrix <- list(earlyj(count_matrices, rowg = T))

set.seed(1234)
time[["GENIE3_early_15Cores"]] <- system.time(
  genie3_early <- infer_networks(early_matrix, method="GENIE3", nCores = 15)
)

```

#### Symmetrize and ROC

```{r}
genie3_early_wadj <- generate_adjacency(genie3_early)
sgenie3_early_wadj <- symmetrize(genie3_early_wadj, weight_function = "mean")
plotROC(sgenie3_early_wadj, adjm, plot_title = "ROC curve - GENIE3 Early Integration", is_binary = F)
```

#### Cutoff

```{r}
sgenie3_early_adj <- cutoff_adjacency(count_matrices = early_matrix,
                                      weighted_adjm_list = sgenie3_early_wadj, 
                                      n = 2,
                                      method = "GENIE3",
                                      nCores = 15)

pscores(adjm, sgenie3_early_adj)
plotg(sgenie3_early_adj)
```

#### Plot comparison

```{r}
compare_consensus(sgenie3_early_adj[[1]], adjm)
```

## GRNBoost2

### Late integration

```{r}
set.seed(1234)
time[["grnboost_late"]] <- system.time(
  grnboost_late <- infer_networks(count_matrices, 
                                method="GRNBoost2",
                                nCores = 15)
)

```

#### Symmetrize and ROC

```{r}
grnboost_late_wadj <- generate_adjacency(grnboost_late)
sgrnboost_late_wadj <- symmetrize(grnboost_late_wadj, weight_function = "mean")

grnboost_late_auc <- plotROC(sgrnboost_late_wadj, adjm, plot_title = "ROC curve - grnboost Late Integration")
```

#### Cutoff

```{r}
sgrnboost_late_adj <- cutoff_adjacency(count_matrices = count_matrices,
                                     weighted_adjm_list = sgrnboost_late_wadj, 
                                     n = 3,
                                     method = "GRNBoost2",
                                     nCores = 15)

scores.grnboost.late.all <- pscores(adjm, sgrnboost_late_adj)
plots <- plotg(sgrnboost_late_adj)

```

#### Consensus

```{r}
consesusm <- create_consensus(sgrnboost_late_adj, method="vote")
consesusu <- create_consensus(sgrnboost_late_adj, method="union")
consesunet <- create_consensus(adj_matrix_list = sgrnboost_late_adj, weighted_list = sgrnboost_late_wadj, method = "INet", threshold = 0.05)

scores.grnboost.late <- pscores(adjm, list(consesusm))
scoresu.grnboost.late <- pscores(adjm, list(consesusu))
scoresnet.grnboost.late <- pscores(adjm, list(consesunet))

```

#### Plot comparison

```{r}
ajm_compared <- compare_consensus(consesusm, adjm)
ajm_compared <- compare_consensus(consesusu, adjm)
ajm_compared <- compare_consensus(consesunet, adjm)
```

### Early integration

```{r}
early_matrix <- list(earlyj(count_matrices))

set.seed(1234)
time[["grnboost_early"]] <- system.time(
  grnboost_early <- infer_networks(early_matrix, method="GRNBoost2")
)

```

#### Symmetrize and ROC

```{r}
grnboost_early_wadj <- generate_adjacency(grnboost_early)
sgrnboost_early_wadj <- symmetrize(grnboost_early_wadj, weight_function = "mean")

plotROC(sgrnboost_early_wadj, adjm, plot_title = "ROC curve - grnboost Early Integration")
```

#### Cutoff

```{r}
sgrnboost_early_adj <- cutoff_adjacency(count_matrices = early_matrix,
                                      weighted_adjm_list = sgrnboost_early_wadj, 
                                      n = 2,
                                      method = "GRNBoost2",
                                      nCores = 15)

scores.grnboost.early <- pscores(adjm, sgrnboost_early_adj)
plots <- plotg(sgrnboost_early_adj)

```

#### Plot comparison

```{r}
ajm_compared <- compare_consensus(sgrnboost_early_adj[[1]], adjm)
```

## ZILGM

### Late integration

```{r}
set.seed(1234)
time[["ZILGM_late_15Cores"]] <- system.time(
  zilgm_late <- infer_networks(count_matrices_list = count_matrices, method = "ZILGM", adjm = adjm, nCores = 15)
)

est_graphs <- zilgm_late$network_results
lambdas <- zilgm_late$lambda_results

```

#### Symmetrize and ROC

```{r}
plotROC(lambdas[[1]], adjm, plot_title = "Lambda ROC Matrix1", is_binary = F)
plotROC(lambdas[[2]], adjm, plot_title = "Lambda ROC Matrix2", is_binary = F)
plotROC(lambdas[[3]], adjm, plot_title = "Lambda ROC Matrix3", is_binary = F)
```

#### Consensus

```{r}
consensus_matrices <- vector("list", 50)

for (i in 1:50) {
  ranklambda <- list(lambdas[[1]][[i]], lambdas[[2]][[i]], lambdas[[3]][[i]])
  consensus_matrices[[i]] <- create_consensus(ranklambda, method="vote")
}

zilgm_late_auc <- plotROC(consensus_matrices, adjm, plot_title = "ROC voting lambda", is_binary = T)

```

#### Plot comparison

```{r ZILGM scores late}
scores.zilgm.late.all <- pscores(adjm, est_graphs)

scores.zilgm.late.all$Statistics %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "scores")
```

```{r ZILGM scores consensus}
consesusm <- create_consensus(est_graphs, method="vote")
consesusu <- create_consensus(est_graphs, method="union")

scores.zilgm.late <- pscores(adjm, list(consesusm))
scoresu.zilgm.late <- pscores(adjm, list(consesusu))

scores.zilgm.late$Statistics %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "scores")
scoresu.zilgm.late$Statistics %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "scores")
```

```{r ZILGM compare late, fig.width=8,fig.width=10}
ajm_compared <- compare_consensus(consesusm, adjm)
ajm_compared <- compare_consensus(consesusu, adjm)
```

### Early integration

```{r ZILGM early}
set.seed(1234)

time[["ZILGM_early_15Cores"]] <- system.time(
  zilgm_late <- infer_networks(count_matrices_list = early_matrix, method = "ZILGM", adjm = adjm, nCores = 15)
)

saveRDS(zilgm_late, "./../analysis/zilgm_early.RDS")

est_graphs <- zilgm_late$network_results
lambdas <- zilgm_late$lambda_results
```

#### Symmetrize and ROC

```{r}
zilgm_early_auc <- plotROC(lambdas[[1]], adjm, plot_title = "ROC ZILGM early", is_binary = T)
```

#### Plot comparison

```{r ZIGLM score early}
scores.zilgm.early <- pscores(adjm, est_graphs)

scores.zilgm.early$Statistics %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "scores")

```

```{r ZILGM compare early, fig.width=8,fig.width=10}
ajm_compared <- compare_consensus(est_graphs[[1]], adjm)
```

## Joint Integration

### Joint Random Forest

```{r JRF inference}
#https://cran.r-project.org/src/contrib/Archive/JRF/
#install.packages("/home/francescoc/Downloads/JRF_0.1-4.tar.gz", repos = NULL, type = "source")
set.seed(1234)
time[["JRF"]] <- system.time(
  jrf_mat <- infer_networks(count_matrices, method="JRF")
)
 
jrf_mat[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "JRF output")

```

#### Their Permutation

```{r}
#jrf_matrices <- lapply(count_matrices, t)
#jrf_matrices_norm <- lapply(jrf_matrices,function(x) {
#  (x - mean(x)) / sd(x)
#  })

#genes <- rownames(jrf_matrices_norm[[1]])

#set.seed(1234)
#out.perm <- Run_permutation(jrf_matrices_norm,mtry=round(sqrt(length(genes)-1)),ntree=500, genes,5)

#myJRF_network <- function(out.jrf, out.perm, TH) {
  
#  nclasses <- dim(out.perm)[3]
#  M <- dim(out.perm)[2]
#  out <- vector("list", nclasses)  

#  for (net in 1:nclasses) { 
#    j.np <- sort(out.jrf[, 2 + net], decreasing = TRUE)
#    FDR <- matrix(0, dim(out.perm)[1], 1)
    
#    th <- NULL  
#    for (s in 1:length(j.np)) { 
#      FP <- sum(sum(out.perm[, , net] >= j.np[s])) / M
#      FDR[s] <- FP / s
      
#      if (FDR[s] > TH) {
#        th <- j.np[s]
#        break
#      }
#    }
    
#    out[[net]] <- out.jrf[out.jrf[, 2 + net] > th, seq(1, 2)]
#  }
  
#  return(out)
#}

#mynet <- myJRF_network(jrf_mat[[1]],out.perm,0.05)
#mynet

```

```{r}
#jrf_adj <- function(df_list, adjm) {
  # Ensure the genes (row and column names) are in the adjacency matrix
#  genes <- rownames(adjm)
  
  # Initialize a list to store adjacency matrices
#  adjacency_matrices <- list()
  
  # Loop through each data frame in the list
#  for (i in seq_along(df_list)) {
#    df <- df_list[[i]]
    
    # Initialize a new adjacency matrix with zeros
#    adj_matrix <- adjm * 0  # Reset to zero for each df
    
    # Update the adjacency matrix for the gene pairs
#    for (j in seq_len(nrow(df))) {
#      gene1 <- df$gene1[j]
#      gene2 <- df$gene2[j]
      
      # Check if both genes are present in the adjacency matrix
#      if (gene1 %in% genes && gene2 %in% genes) {
#        idx1 <- which(genes == gene1)  # Find the row index for gene1
#        idx2 <- which(genes == gene2)  # Find the column index for gene2
        
        # Update the adjacency matrix to set an edge
#        adj_matrix[idx1, idx2] <- 1
#        adj_matrix[idx2, idx1] <- 1  # Ensure symmetry
#      } else {
#        warning(paste("Gene pair not found in adjm:", gene1, "-", gene2))
#      }
#    }
    
    # Store the resulting adjacency matrix in the list
#    adjacency_matrices[[i]] <- adj_matrix
#  }
  
  # Return the list of adjacency matrices
#  return(adjacency_matrices)
#}


#jrf_adj_mynet <- jrf_adj(mynet, adjm)

```

```{r}
#jrf_auc_perm <- plotROC(jrf_adj_mynet, adjm, plot_title = "ROC curve - JRF perm out", is_binary = T)
```

```{r JRF perm scores}
#scores.jrf.perm <- pscores(adjm, jrf_adj_mynet)

#scores.jrf.perm$Statistics %>%
#    datatable(extensions = 'Buttons',
#              options = list(
#                dom = 'Bfrtip',
#                buttons = c('csv', 'excel'),
#                scrollX = TRUE,
#                pageLength = 10), 
#              caption = "scores")
```

```{r JRF perm plotg}
#plots <- plotg(jrf_adj_mynet)
```

```{r JRF consensus and score their perm}
#consesusu <- create_consensus(jrf_adj_mynet, method="union")

#scoresu.jrf.perm <- pscores(adjm, list(consesusu))

#scoresu.jrf.perm$Statistics %>%
#    datatable(extensions = 'Buttons',
#              options = list(
#                dom = 'Bfrtip',
#                buttons = c('csv', 'excel'),
#                scrollX = TRUE,
#                pageLength = 10), 
#              caption = "scores")

```

```{r JRF compare their perm, fig.width=8,fig.width=10}
#ajm_compared <- compare_consensus(consesusu, adjm)
```

#### Prepare the output

```{r}
jrf_list <- list()

importance_columns <- grep("importance", names(jrf_mat[[1]]), value = TRUE)

for (i in seq_along(importance_columns)) {
# Select the 'gene1', 'gene2', and the current 'importance' column
  df <- jrf_mat[[1]][, c("gene1", "gene2", importance_columns[i])]
  
  # Rename the importance column to its original name (e.g., importance1, importance2, etc.)
  names(df)[3] <- importance_columns[i]
  
  # Add the data frame to the output list
  jrf_list[[i]] <- df
}

saveRDS(jrf_list, "./../analysis/jrf.RDS")

jrf_list[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "JRF output")
```

#### symmetrize Output and ROC

```{r JRF symmetrizeROC late}
jrf_wadj <- generate_adjacency(jrf_list)
sjrf_wadj <- symmetrize(jrf_wadj, weight_function = "mean")
jrf_auc_mine <- plotROC(sjrf_wadj, adjm, plot_title = "ROC curve - JRF Late Integration", is_binary = F)

sjrf_wadj[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "JRF symmetrize output")
```

#### Generate Adjacency and Apply Cutoff

```{r JRF cutoff late}
sjrf_adj <- cutoff_adjacency(count_matrices = count_matrices,
                 weighted_adjm_list = sjrf_wadj, 
                 ground.truth = adjm,
                 n = 3,
                 method = "JRF")

sjrf_adj[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "JRF adjacency")

```

#### Comparison with the Ground Truth

```{r JRF metrics late}
scores.jrf.all <- pscores(adjm, sjrf_adj)

scores.jrf.all$Statistics %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "scores")
```

```{r JRF plotg late}
plots <- plotg(sjrf_adj)
```

```{r JRF consensus and score late}
consesusm <- create_consensus(sjrf_adj, method="vote")
consesusu <- create_consensus(sjrf_adj, method="union")
consesunet <- create_consensus(adj_matrix_list = sjrf_adj, weighted_list = sjrf_wadj, method = "INet", threshold = 0.1, ncores = 15)

scores.jrf <- pscores(adjm, list(consesusm))
scoresu.jrf <- pscores(adjm, list(consesusu))
scoresnet.jrf <- pscores(adjm, list(consesunet))

scores.jrf$Statistics %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "scores vote")

scoresu.jrf$Statistics %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "scores union")

scoresnet.jrf$Statistics %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "scores INet")

```

```{r JRF compare late, fig.width=8,fig.width=10}
ajm_compared <- compare_consensus(consesusm, adjm)
ajm_compared <- compare_consensus(consesusu, adjm)
ajm_compared <- compare_consensus(consesunet, adjm)
```
