setwd("/home/francescoc/Desktop/Project/tdsc/scData_simulation")
source("simulate_data.R")
# Load necessary library
library(Matrix)
# Set the parameters
set.seed(42)  # For reproducibility
n_cells <- 100  # Number of T cells
n_genes <- 2000  # Number of genes (e.g., from T-cell markers and other genes)
mean_expression <- 10  # Mean expression value per gene
t_cell_marker_genes <- c("CD3D", "CD3E", "CD3G", "CD4", "CD8A", "CD8B")
# Step 1: Create a random gene expression matrix
# Simulate gene expression counts using a Negative Binomial distribution
gene_expression_matrix <- matrix(rnbinom(n_cells * n_genes, size=1, mu=mean_expression),
nrow=n_genes,
ncol=n_cells)
# Step 2: Add cell and gene names
gene_names <- paste0("Gene", 1:n_genes)  # Default gene names
colnames(gene_expression_matrix) <- paste0("Cell_", 1:n_cells)
rownames(gene_expression_matrix) <- gene_names
# Step 3: Simulate higher expression for T cell marker genes
# Let's simulate higher expression of some T cell marker genes
for (marker in t_cell_marker_genes) {
if (marker %in% gene_names) {
gene_expression_matrix[which(gene_names == marker), ] <- rnbinom(n_cells, size=1, mu=50)  # Higher expression
}
}
# Step 4: Add dropout noise (optional)
dropout_rate <- 0.1  # Assume 10% dropout rate
dropout_matrix <- matrix(rbinom(n_cells * n_genes, 1, dropout_rate), nrow=n_genes, ncol=n_cells)
gene_expression_matrix[dropout_matrix == 1] <- 0
# Step 5: Create a sparse matrix to save memory (optional)
sparse_gene_expression_matrix <- Matrix(gene_expression_matrix, sparse = TRUE)
# View the first few rows and columns of the matrix
head(gene_expression_matrix[, 1:5])
dim(gene_expression_matrix)
# Read the data
file_path <- "/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt"  # Replace with your actual file path
data <- read.table(file_path, header = FALSE, sep = "\t", stringsAsFactors = FALSE)
# Assign column names to the data frame
colnames(data) <- c("Gene1", "Gene2", "Weight", "NetworkGroup", "Network")
# Create a list of unique genes
genes <- unique(c(data$Gene1, data$Gene2))
# Initialize an adjacency matrix with zeros
adj_matrix <- matrix(0, nrow = length(genes), ncol = length(genes),
dimnames = list(genes, genes))
# Populate the adjacency matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$Weight[i]
# Assign weight to both gene pairs (symmetrically)
adj_matrix[gene1, gene2] <- weight
adj_matrix[gene2, gene1] <- weight
}
# Convert the adjacency matrix to a data frame for easier viewing
adj_matrix_df <- as.data.frame(adj_matrix)
# Print the adjacency matrix
print(adj_matrix_df)
# Save the adjacency matrix to a CSV file (optional)
write.csv(adj_matrix_df, "adjacency_matrix.csv", row.names = TRUE)
# Read the data
file_path <- "/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt"  # Replace with your actual file path
# Load necessary library
library(dplyr)
data <- read.table(file_path, header = T, sep = "\t", stringsAsFactors = FALSE)
# Assign column names to the data frame
colnames(data) <- c("Gene1", "Gene2", "Weight", "NetworkGroup", "Network")
# Create a list of unique genes
genes <- unique(c(data$Gene1, data$Gene2))
# Initialize an adjacency matrix with zeros
adj_matrix <- matrix(0, nrow = length(genes), ncol = length(genes),
dimnames = list(genes, genes))
# Populate the adjacency matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$Weight[i]
# Assign weight to both gene pairs (symmetrically)
adj_matrix[gene1, gene2] <- weight
adj_matrix[gene2, gene1] <- weight
}
# Convert the adjacency matrix to a data frame for easier viewing
adj_matrix_df <- as.data.frame(adj_matrix)
# Print the adjacency matrix
print(adj_matrix_df)
View
View(adj_matrix_df)
# Save the adjacency matrix to a CSV file (optional)
write.csv(adj_matrix_df, "adjacency_matrix.csv", row.names = TRUE)
# Load necessary library
library(dplyr)
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
# Load necessary library
library(dplyr)
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
# Read the data
file_path <- "genemania-interactions.txt"  # Replace with your actual file path
data <- read.table(file_path, header = T, sep = "\t", stringsAsFactors = FALSE)
# Load necessary library
library(dplyr)
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
getwd()
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/Bnet")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable")
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",")
marker <- read.table("./../data/Tcell.marker.csv", header = T, sep = ",")
count_matrices <- list()
for (i in 1:5) {
count_matrix_i <- as.data.frame(count_matrix[[i]])
colnames(count_matrix_i) <- colnames(adjm)
rownames(count_matrix_i) <- paste("cell", 1:nrow(count_matrix_i), sep = "")
count_matrices[[i]] <- count_matrix_i
}
count_matrices[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "Simulated count matrix")
set.seed(123)
regulatory_network_genie3 <- GENIE3(t(count_matrices[[1]]))
# Extract link list (gene regulatory interactions) from GENIE3 results
link_list_genie3 <- getLinkList(regulatory_network_genie3)
link_list_genie3 %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GENIE3 output")
write.csv(link_list_genie3, "genie3_network.csv", row.names = FALSE)
gene_names <- unique(c(link_list_genie3$regulator, link_list_genie3$target))
adj_matrix_genie3 <- matrix(0, nrow = length(gene_names), ncol = length(gene_names))
rownames(adj_matrix_genie3) <- colnames(adj_matrix_genie3) <- gene_names
# Fill the adjacency matrix based on the links from GENIE3 with a weight condition
for (i in 1:nrow(link_list_genie3)) {
regulator <- link_list_genie3$regulator[i]
target <- link_list_genie3$target[i]
weight <- link_list_genie3$weight[i]
# Only set 1 if the weight is >= 0.1
if (weight >= 0.1) {
adj_matrix_genie3[regulator, target] <- 1
}
}
adj_matrix_genie3 %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GENIE3 adjacency matrix 0.1")
write.csv(adj_matrix_genie3, "genie3_adjacency_matrix.csv")
# Create igraph objects for both networks
graph_genie3 <- graph_from_adjacency_matrix(adj_matrix_genie3, mode = "undirected")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "undirected")
par(mfrow = c(1, 2))
# Plot GENIE3 Network
plot(graph_genie3, main = "GENIE3 Inferred Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
# Plot Provided Network
plot(graph_provided, main = "Provided Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
par(mfrow = c(1, 1))
#sudo apt-get install python3-venv
py_install("arboreto", envname = "r-reticulate")
#sudo apt-get install python3-venv
py_install("arboreto", envname = "r-reticulate")
#sudo apt-get install python3-venv
py_install("arboreto")
#sudo apt-get install python3-venv
use_python("/usr/bin/python3", required = TRUE)  # Adjust path if needed
#sudo apt-get install python3-venv
use_python("/usr/bin/python3", required = TRUE)
# Install Python packages
py_install("arboreto")
py_install("pandas")
#sudo apt-get install python3-venv
use_python("/usr/bin/python3", required = TRUE)
# Check Python configuration to ensure it's using the correct Python version
py_config()
# Import necessary Python modules
arboreto <- import("arboreto")
pandas <- import("pandas")
numpy <- import("numpy")
# Check Python configuration to ensure it's using the correct Python version
py_config()
# Prepare the data for GRNBoosti2
# Assuming count_matrix is already loaded from previous code
count_matrix_df <- as.data.frame(t(count_matrices[[1]]))  # Transpose to have genes in rows
genes <- rownames(count_matrix_df)
cells <- colnames(count_matrix_df)
# Convert R data frame to Pandas data frame for GRNBoost2
df_pandas <- pandas$DataFrame(data = count_matrix_df)
# Run GRNBoost2 to infer the gene regulatory network
# arboreto.grnboost2 requires expression matrix (as pandas DataFrame) and a list of gene names
grn_links <- arboreto$grnboost2$grnboost2(expression_matrix = df_pandas, gene_names = genes)
# Prepare the data for GRNBoost2 (assumes your count matrix is already available)
count_matrix_df <- as.data.frame(t(count_matrices[[1]]))  # Transpose the matrix
genes <- rownames(count_matrix_df)
# Convert R data frame to Pandas data frame
df_pandas <- pandas$DataFrame(data = count_matrix_df)
# Run GRNBoost2 to infer gene regulatory networks
grn_links <- arboreto$grnboost2$grnboost2(expression_matrix = df_pandas, gene_names = genes)
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")
count_matrix_df <- as.data.frame(t(count_matrices[[1]]))  # Transpose the matrix
genes <- rownames(count_matrix_df)
df_pandas <- pandas$DataFrame(data = count_matrix_df)
# Run GRNBoost2 to infer gene regulatory networks
grn_links <- arboreto$grnboost2$grnboost2(expression_matrix = df_pandas, gene_names = genes)
# Run GRNBoost2 to infer gene regulatory networks
grn_links <- arboreto$grnboost2(expression_matrix = df_pandas, gene_names = genes)
arboreto$grnboost2
# Run GRNBoost2 to infer gene regulatory networks
grn_links <- arboreto$grnboost2$grnboost2(expression_matrix = df_pandas, gene_names = genes)
# Run GRNBoost2 to infer gene regulatory networks
grn_links <- arboreto$grnboost2(expression_matrix = df_pandas, gene_names = genes)
# Check the attributes of arboreto to ensure the correct submodule
py_list_attributes(import("arboreto"))
# Prepare the data for GRNBoost2
count_matrix_df <- as.data.frame(t(count_matrices[[1]]))  # Transpose matrix
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")
# Prepare the data for GRNBoost2
count_matrix_df <- as.data.frame(t(count_matrices[[1]]))  # Transpose matrix
genes <- rownames(count_matrix_df)
# Convert R data frame to a numpy array and prepare for GRNBoost2
df_numpy <- numpy$array(count_matrix_df)
# Run GRNBoost2 from the correct submodule
grn_links <- arboreto_algo$grnboost2(expression_matrix = df_numpy, gene_names = genes)
# Run GRNBoost2 from the correct submodule
grn_links <- arboreto$grnboost2(expression_matrix = df_numpy, gene_names = genes)
# Run GRNBoost2 from the correct submodule
grn_links <- arboreto$grnboost2(df_numpy, gene_names = genes)
df_numpy
count_matrix_df <- as.data.frame(t(count_matrices[[1]]))  # Transpose matrix
head(count_matrix_df)
genes <- rownames(count_matrix_df)
genes
# Convert R data frame to a numpy array and prepare for GRNBoost2
df_numpy <- numpy$array(count_matrix_df)
head(df_numpy)
# Convert R data frame to a numpy array and prepare for GRNBoost2
df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = colnames(count_matrix_df), index = genes)
head(df_pandas)
grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
# Convert the Python result back into an R data frame
grn_network <- py_to_r(grn_links)
v
grn_links
grn_links %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GRNBoost2 links")
#sudo apt-get install python3-venv
use_python("/usr/bin/python3", required = TRUE)
py_config()
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")
count_matrix_df <- as.data.frame(count_matrices[[1]])
genes <- colnames(count_matrix_df)
df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = colnames(count_matrix_df), index = genes)
grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
grn_links %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GRNBoost2 links")
grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
View(df_pandas)
count_matrix_df <- as.data.frame(count_matrices[[1]])
genes <- colnames(count_matrix_df)
colnames(count_matrix_df)
head(count_matrix_df)
df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = colnames(count_matrix_df), index = genes)
head(df_pandas)
df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = genes, index = rownames(count_matrix_df))
head(df_pandas)
grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
grn_links %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GRNBoost2 links")
# Convert the Python result back into an R data frame
grn_network <- py_to_r(grn_links)
grn_links %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GRNBoost2 links")
unique_genes <- unique(c(grn_network$TF, grn_network$target))  # Get unique genes from GRNBoost2
unique_genes <- unique(c(grn_links$TF, grn_links$target))  # Get unique genes from GRNBoost2
adj_matrix_grnboost <- matrix(0, nrow = length(unique_genes), ncol = length(unique_genes))
rownames(adj_matrix_grnboost) <- unique_genes
colnames(adj_matrix_grnboost) <- unique_genes
for (i in 1:nrow(grn_links)) {
tf <- grn_links$TF[i]
target <- grn_network$target[i]
adj_matrix_grnboost[tf, target] <- 1  # Set the edge in the adjacency matrix
}
for (i in 1:nrow(grn_links)) {
tf <- grn_links$TF[i]
target <- grn_links$target[i]
adj_matrix_grnboost[tf, target] <- 1  # Set the edge in the adjacency matrix
}
adj_matrix_original <- as.matrix(adjm)
graph_grnboost <- graph_from_adjacency_matrix(adj_matrix_grnboost, mode = "undirected")
graph_original <- graph_from_adjacency_matrix(adj_matrix_original, mode = "undirected")
head(adj_matrix_grnboost)
# Set up side-by-side plotting
par(mfrow = c(1, 2))
# Plot GRNBoost2 Network
plot(graph_grnboost, main = "GRNBoost2 Inferred Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
# Plot Original Network
plot(graph_original, main = "Original Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
# Reset plotting layout
par(mfrow = c(1, 1))
\[
MSE = rac{1}{n} \sum_{i=1}^{n} \left( y_g^{(i)} - f(X^{(i)})
ight)^2
\]
?opts_chunk
?opts_chunk$set
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/analysis")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable")
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
# Load necessary library
library(dplyr)
setwd("/home/francescoc/Desktop/scGRN_simulation/data")
# Read the data
file_path <- "string_interactions.tsv"  # Replace with your actual file path
data <- read.table(file_path, header = F, sep = "\t", stringsAsFactors = FALSE)
# Assign column names to the data frame
colnames(data) <- c("Gene1","Gene2","node1_string_id","node2_string_id","neighborhood_on_chromosome","gene_fusion","phylogenetic_cooccurrence","homology","coexpression","experimentally_determined_interaction","database_annotated","automated_textmining","combined_score")
# Create a list of unique genes
genes <- unique(c(data$Gene1, data$Gene2))
# Initialize an adjacency matrix with zeros
adj_matrix <- matrix(0, nrow = length(genes), ncol = length(genes),
dimnames = list(genes, genes))
# Populate the adjacency matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$combined_score[i]
# Assign weight to both gene pairs (symmetrically)
adj_matrix[gene1, gene2] <- weight
adj_matrix[gene2, gene1] <- weight
}
# Convert the adjacency matrix to a data frame for easier viewing
adj_matrix_df <- as.data.frame(adj_matrix)
# Print the adjacency matrix
print(adj_matrix_df)
# Save the adjacency matrix to a CSV file (optional)
write.csv(adj_matrix_df, "weighted_adjacency_matrix.csv", row.names = TRUE)
# Convert all values greater than 0 to 1
adj_matrix_df[adj_matrix_df > 0] <- 1
# Save the transformed data to a new CSV file
write.csv(adj_matrix_df, "adjacency_matrix.csv", row.names = TRUE)
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/analysis")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("drisso/learn2count")
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn)
library(learn2count)
#count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",")
marker <- read.table("./../data/Tcell.marker.csv", header = T, sep = ",")
?simdata
ncell <- 1000
nrow(adjm)
nodes <- nrow(adjm)
simdata(n=ncell, p=nodes, B=adjm, family = "ZINB", mu = 1.5)
simdata(n=ncell, p=nodes, B=adjm, family = "ZINB", mu = 1.5, theta = 0.125)
simdata(n=ncell, p=nodes, B=adjm, family = "ZINB", mu=1.5, theta=0.125, pi=0.2)
View(adjm)
# Load necessary library
library(dplyr)
setwd("/home/francescoc/Desktop/scGRN_simulation/data")
# Read the data
file_path <- "string_interactions.tsv"  # Replace with your actual file path
data <- read.table(file_path, header = F, sep = "\t", stringsAsFactors = FALSE)
# Assign column names to the data frame
colnames(data) <- c("Gene1","Gene2","node1_string_id","node2_string_id","neighborhood_on_chromosome","gene_fusion","phylogenetic_cooccurrence","homology","coexpression","experimentally_determined_interaction","database_annotated","automated_textmining","combined_score")
# Create a list of unique genes
genes <- unique(c(data$Gene1, data$Gene2))
# Initialize an adjacency matrix with zeros and set diagonal to 1
adj_matrix <- matrix(0, nrow = length(genes), ncol = length(genes),
dimnames = list(genes, genes))
# Set diagonal elements to 1 (for self-loops)
diag(adj_matrix) <- 1
# Populate the adjacency matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$combined_score[i]
# Assign weight to both gene pairs (symmetrically)
adj_matrix[gene1, gene2] <- weight
adj_matrix[gene2, gene1] <- weight
}
# Convert the adjacency matrix to a data frame for easier viewing
adj_matrix_df <- as.data.frame(adj_matrix)
# Print the adjacency matrix
print(adj_matrix_df)
# Save the adjacency matrix to a CSV file (optional)
write.csv(adj_matrix_df, "weighted_adjacency_matrix.csv", row.names = TRUE)
# Convert all values greater than 0 to 1
adj_matrix_df[adj_matrix_df > 0] <- 1
# Save the transformed data to a new CSV file
write.csv(adj_matrix_df, "adjacency_matrix.csv", row.names = TRUE)
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/analysis")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable")
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
#count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",")
marker <- read.table("./../data/Tcell.marker.csv", header = T, sep = ",")
ncell <- 1000
nodes <- nrow(adjm)
simdata(n=ncell, p=nodes, B=adjm, family = "ZINB", mu=1.5, theta=0.125, pi=0.2)
View(adjm)
class(adjm)
#count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()
marker <- read.table("./../data/Tcell.marker.csv", header = T, sep = ",")
ncell <- 1000
nodes <- nrow(adjm)
simdata(n=ncell, p=nodes, B=adjm, family = "ZINB", mu=1.5, theta=0.125, pi=0.2)
simdata(n=ncell, p=nodes, B=adjm, family = "ZINB", mu=5, mu_noise = 1, theta=1, pi=0.2)
colnames(adjm)
#count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()
marker <- read.table("./../data/Tcell.marker.csv", header = T, sep = ",")
#count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()
ncell <- 1000
nodes <- nrow(adjm)
count_matrices <- simdata(n=ncell, p=nodes, B=adjm, family = "ZINB", mu=5, mu_noise = 1, theta=1, pi=0.2)
for (i in 1:3) {
count_matrices <- simdata(n = ncell, p = nodes, B = adjm, family = "ZINB",
mu = 5, mu_noise = 1, theta = 1, pi = 0.2)
count_matrices_list[[i]] <- count_matrices
}
count_matrices_list <- list()
for (i in 1:3) {
count_matrices <- simdata(n = ncell, p = nodes, B = adjm, family = "ZINB",
mu = 5, mu_noise = 1, theta = 1, pi = 0.2)
count_matrices_list[[i]] <- count_matrices
}
count_matrices <- lapply(1:5, function(i) {
# Generate count matrix using simdata function
count_matrix_i <- simdata(n = ncell, p = nodes, B = adjm, family = "ZINB",
mu = 5, mu_noise = 1, theta = 1, pi = 0.2)
# Convert the matrix to a data frame and set column and row names
count_matrix_df <- as.data.frame(count_matrix_i)
colnames(count_matrix_df) <- colnames(adjm)
rownames(count_matrix_df) <- paste("cell", 1:nrow(count_matrix_df), sep = "")
# Return the formatted data frame for this iteration
return(count_matrix_df)
})
count_matrices[[1]]
count_matrices[[2]]
count_matrices[[1]]
count_matrices[[3]]
