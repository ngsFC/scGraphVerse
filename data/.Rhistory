gene_names = genes
)
result_r <- reticulate::py_to_r(result_py)
if (is.data.frame(result_r)) {
rownames(result_r) <- NULL
}
result_r
}
} else if (method == "ZILGM") {
#' @param count_matrices_list A list of expression matrices (genes × cells) or Seurat / SingleCellExperiment objects.
#' @param method Character. One of: "GENIE3", "GRNBoost2", "ZILGM", "JRF", "PCzinb".
#' @param adjm Optional adjacency matrix (used to rename output matrices).
#' @param nCores Number of CPU cores to use for parallel computation.
#' @param grnboost_modules Python modules list returned by `init_py()`, required for GRNBoost2.
#'
#' @return A list of inferred networks (format varies by method).
#'
#' @importFrom BiocParallel bplapply bpworkers bpparam MulticoreParam
#' @export
infer_networks <- function(count_matrices_list,
method = "GENIE3",
adjm = NULL,
total_cores = BiocParallel::bpworkers(BiocParallel::bpparam()),
grnboost_modules = NULL,
seed = 123) {
method <- match.arg(method, c("GENIE3", "GRNBoost2", "ZILGM", "JRF", "PCzinb"))
# Define outer and inner cores based on method
n_matrices <- length(count_matrices_list)
if (method == "GRNBoost2") {
param_outer <- BiocParallel::SerialParam()
nCores_inner <- total_cores
} else {
nCores_outer <- min(total_cores, n_matrices)
nCores_inner <- max(floor(total_cores / nCores_outer), 1)
param_outer <- BiocParallel::MulticoreParam(workers = nCores_outer, RNGseed = seed)
}
count_matrices_list <- lapply(count_matrices_list, function(obj) {
if (inherits(obj, "Seurat")) {
as.matrix(Seurat::GetAssayData(obj, assay = "RNA", slot = "counts"))
} else if (inherits(obj, "SingleCellExperiment")) {
as.matrix(SummarizedExperiment::assay(obj, "counts"))
} else {
as.matrix(obj)
}
})
BiocParallel::bplapply(seq_along(count_matrices_list), function(i) {
mat <- count_matrices_list[[i]]
task_seed <- as.integer(round(seed * 100 + i))
set.seed(task_seed)
if (method == "GENIE3") {
adj <- GENIE3::GENIE3(mat, nCores = nCores_inner)
GENIE3::getLinkList(adj)
} else if (method == "GRNBoost2") {
if (is.null(grnboost_modules)) stop("Provide grnboost_modules for GRNBoost2.")
grnboost_modules$numpy$random$seed(as.integer(task_seed))
df <- as.data.frame(t(mat))
genes <- colnames(df)
rownames(df) <- make.unique(rownames(df))  # Ensure unique cell names
df_pandas <- grnboost_modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes,
index = rownames(df)
)
result_py <- grnboost_modules$arboreto$grnboost2(
expression_data = df_pandas,
gene_names = genes
)
result_r <- reticulate::py_to_r(result_py)
if (is.data.frame(result_r)) {
rownames(result_r) <- NULL
}
result_r
} else if (method == "ZILGM") {
lambda_max <- ZILGM::find_lammax(t(mat))
lambda_seq <- exp(seq(log(lambda_max), log(1e-4 * lambda_max), length.out = 50))
fit <- ZILGM::zilgm(X = t(mat), lambda = lambda_seq, family = "NBII",
update_type = "IRLS", do_boot = TRUE, boot_num = 10,
sym = "OR", nCores = nCores_inner)
adj <- fit$network[[fit$opt_index]]
dimnames(adj) <- if (is.null(adjm)) list(rownames(mat), rownames(mat)) else dimnames(adjm)
adj
} else if (method == "PCzinb") {
param_inner <- BiocParallel::MulticoreParam(workers = nCores_inner, RNGseed = task_seed)
adj <- learn2count::PCzinb(t(mat), method = "zinb1", maxcard = 2)
dimnames(adj) <- if (is.null(adjm)) list(rownames(mat), rownames(mat)) else dimnames(adjm)
adj
} else if (method == "JRF") {
param_inner <- BiocParallel::MulticoreParam(workers = nCores_inner, RNGseed = task_seed)
norm_mat <- t(scale(t(mat)))
rf <- JRF::JRF(X = list(norm_mat),
genes.name = rownames(norm_mat),
ntree = 500,
mtry = round(sqrt(nrow(norm_mat) - 1)))
rf
}
}, BPPARAM = param_outer)
}
# GRNBoost2
## Late integration
time[["GRNBoost2_late"]] <- system.time(
late <- infer_networks(count_matrices,
method="GRNBoost2",
grnboost_modules = modules,
total_cores = 15,
seed=seed_base+run_id)
)
head(late)
late_wadj <- generate_adjacency(late)
slate_wadj <- symmetrize(late_wadj, weight_function = "mean")
late_auc <- plotROC(slate_wadj, adjm, plot_title = "ROC curve - grnboost Late Integration")
slate_adj <- cutoff_adjacency(count_matrices = count_matrices,
weighted_adjm_list = slate_wadj,
n = 3,
method = "GRNBoost2",
grnboost_modules = modules)
#'
#' Sets the Python path and imports required Python modules (arboreto, pandas, numpy)
#' for running GRNBoost2.
#'
#' @param python_path Path to the Python executable (e.g., "/usr/bin/python3").
#' @param required Logical. If TRUE, throws an error if Python is not available.
#'
#' @return A list containing Python modules: arboreto, pandas, and numpy.
#'
#' @export
init_py <- function(python_path = "/usr/bin/python3", required = TRUE) {
reticulate::use_python(python_path, required = required)
modules <- list(
grnboost2 = reticulate::import("arboreto.utils", delay_load = TRUE)$grnboost2_expression_data,
#arboreto = reticulate::import("arboreto.algo", delay_load = TRUE),
pandas   = reticulate::import("pandas", delay_load = TRUE),
numpy    = reticulate::import("numpy", delay_load = TRUE)
)
message("Python modules successfully loaded.")
return(modules)
}
#' @param count_matrices_list A list of expression matrices (genes × cells) or Seurat / SingleCellExperiment objects.
#' @param method Character. One of: "GENIE3", "GRNBoost2", "ZILGM", "JRF", "PCzinb".
#' @param adjm Optional adjacency matrix (used to rename output matrices).
#' @param nCores Number of CPU cores to use for parallel computation.
#' @param grnboost_modules Python modules list returned by `init_py()`, required for GRNBoost2.
#'
#' @return A list of inferred networks (format varies by method).
#'
#' @importFrom BiocParallel bplapply bpworkers bpparam MulticoreParam
#' @export
infer_networks <- function(count_matrices_list,
method = "GENIE3",
adjm = NULL,
total_cores = BiocParallel::bpworkers(BiocParallel::bpparam()),
grnboost_modules = NULL,
seed = 123) {
method <- match.arg(method, c("GENIE3", "GRNBoost2", "ZILGM", "JRF", "PCzinb"))
# Define outer and inner cores based on method
n_matrices <- length(count_matrices_list)
if (method == "GRNBoost2") {
param_outer <- BiocParallel::SerialParam()
nCores_inner <- total_cores
} else {
nCores_outer <- min(total_cores, n_matrices)
nCores_inner <- max(floor(total_cores / nCores_outer), 1)
param_outer <- BiocParallel::MulticoreParam(workers = nCores_outer, RNGseed = seed)
}
count_matrices_list <- lapply(count_matrices_list, function(obj) {
if (inherits(obj, "Seurat")) {
as.matrix(Seurat::GetAssayData(obj, assay = "RNA", slot = "counts"))
} else if (inherits(obj, "SingleCellExperiment")) {
as.matrix(SummarizedExperiment::assay(obj, "counts"))
} else {
as.matrix(obj)
}
})
BiocParallel::bplapply(seq_along(count_matrices_list), function(i) {
mat <- count_matrices_list[[i]]
task_seed <- as.integer(round(seed * 100 + i))
set.seed(task_seed)
if (method == "GENIE3") {
adj <- GENIE3::GENIE3(mat, nCores = nCores_inner)
GENIE3::getLinkList(adj)
} else if (method == "GRNBoost2") {
if (is.null(grnboost_modules)) stop("Provide grnboost_modules for GRNBoost2.")
grnboost_modules$numpy$random$seed(as.integer(task_seed))
df <- as.data.frame(t(mat))
genes <- colnames(df)
rownames(df) <- make.unique(rownames(df))  # Ensure unique cell names
df_pandas <- grnboost_modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes,
index = rownames(df)
)
result_py <- grnboost_modules$grnboost2(
expression_data = df_pandas,
gene_names = genes
)
result_r <- reticulate::py_to_r(result_py)
if (is.data.frame(result_r)) {
rownames(result_r) <- NULL
}
result_r
} else if (method == "ZILGM") {
lambda_max <- ZILGM::find_lammax(t(mat))
lambda_seq <- exp(seq(log(lambda_max), log(1e-4 * lambda_max), length.out = 50))
fit <- ZILGM::zilgm(X = t(mat), lambda = lambda_seq, family = "NBII",
update_type = "IRLS", do_boot = TRUE, boot_num = 10,
sym = "OR", nCores = nCores_inner)
adj <- fit$network[[fit$opt_index]]
dimnames(adj) <- if (is.null(adjm)) list(rownames(mat), rownames(mat)) else dimnames(adjm)
adj
} else if (method == "PCzinb") {
param_inner <- BiocParallel::MulticoreParam(workers = nCores_inner, RNGseed = task_seed)
adj <- learn2count::PCzinb(t(mat), method = "zinb1", maxcard = 2)
dimnames(adj) <- if (is.null(adjm)) list(rownames(mat), rownames(mat)) else dimnames(adjm)
adj
} else if (method == "JRF") {
param_inner <- BiocParallel::MulticoreParam(workers = nCores_inner, RNGseed = task_seed)
norm_mat <- t(scale(t(mat)))
rf <- JRF::JRF(X = list(norm_mat),
genes.name = rownames(norm_mat),
ntree = 500,
mtry = round(sqrt(nrow(norm_mat) - 1)))
rf
}
}, BPPARAM = param_outer)
}
# GRNBoost2
## Late integration
time[["GRNBoost2_late"]] <- system.time(
late <- infer_networks(count_matrices,
method="GRNBoost2",
grnboost_modules = modules,
total_cores = 15,
seed=seed_base+run_id)
)
modules <- init_py(python_path ="/usr/bin/python3", required = TRUE)
#' @param count_matrices_list A list of expression matrices (genes × cells) or Seurat / SingleCellExperiment objects.
#' @param method Character. One of: "GENIE3", "GRNBoost2", "ZILGM", "JRF", "PCzinb".
#' @param adjm Optional adjacency matrix (used to rename output matrices).
#' @param nCores Number of CPU cores to use for parallel computation.
#' @param grnboost_modules Python modules list returned by `init_py()`, required for GRNBoost2.
#'
#' @return A list of inferred networks (format varies by method).
#'
#' @importFrom BiocParallel bplapply bpworkers bpparam MulticoreParam
#' @export
infer_networks <- function(count_matrices_list,
method = "GENIE3",
adjm = NULL,
total_cores = BiocParallel::bpworkers(BiocParallel::bpparam()),
grnboost_modules = NULL,
seed = 123) {
method <- match.arg(method, c("GENIE3", "GRNBoost2", "ZILGM", "JRF", "PCzinb"))
# Define outer and inner cores based on method
n_matrices <- length(count_matrices_list)
if (method == "GRNBoost2") {
param_outer <- BiocParallel::SerialParam()
nCores_inner <- total_cores
} else {
nCores_outer <- min(total_cores, n_matrices)
nCores_inner <- max(floor(total_cores / nCores_outer), 1)
param_outer <- BiocParallel::MulticoreParam(workers = nCores_outer, RNGseed = seed)
}
count_matrices_list <- lapply(count_matrices_list, function(obj) {
if (inherits(obj, "Seurat")) {
as.matrix(Seurat::GetAssayData(obj, assay = "RNA", slot = "counts"))
} else if (inherits(obj, "SingleCellExperiment")) {
as.matrix(SummarizedExperiment::assay(obj, "counts"))
} else {
as.matrix(obj)
}
})
BiocParallel::bplapply(seq_along(count_matrices_list), function(i) {
mat <- count_matrices_list[[i]]
task_seed <- as.integer(round(seed * 100 + i))
set.seed(task_seed)
if (method == "GENIE3") {
adj <- GENIE3::GENIE3(mat, nCores = nCores_inner)
GENIE3::getLinkList(adj)
} else if (method == "GRNBoost2") {
if (is.null(grnboost_modules)) stop("Provide grnboost_modules for GRNBoost2.")
grnboost_modules$numpy$random$seed(as.integer(task_seed))
df <- as.data.frame(t(mat))
genes <- colnames(df)
rownames(df) <- make.unique(rownames(df))  # Ensure unique cell names
df_pandas <- grnboost_modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes,
index = rownames(df)
)
result_py <- grnboost_modules$arboreto$grnboost2(
expression_data = df_pandas,
gene_names = genes
)
result_r <- reticulate::py_to_r(result_py)
if (is.data.frame(result_r)) {
rownames(result_r) <- NULL
}
result_r
} else if (method == "ZILGM") {
lambda_max <- ZILGM::find_lammax(t(mat))
lambda_seq <- exp(seq(log(lambda_max), log(1e-4 * lambda_max), length.out = 50))
fit <- ZILGM::zilgm(X = t(mat), lambda = lambda_seq, family = "NBII",
update_type = "IRLS", do_boot = TRUE, boot_num = 10,
sym = "OR", nCores = nCores_inner)
adj <- fit$network[[fit$opt_index]]
dimnames(adj) <- if (is.null(adjm)) list(rownames(mat), rownames(mat)) else dimnames(adjm)
adj
} else if (method == "PCzinb") {
param_inner <- BiocParallel::MulticoreParam(workers = nCores_inner, RNGseed = task_seed)
adj <- learn2count::PCzinb(t(mat), method = "zinb1", maxcard = 2)
dimnames(adj) <- if (is.null(adjm)) list(rownames(mat), rownames(mat)) else dimnames(adjm)
adj
} else if (method == "JRF") {
param_inner <- BiocParallel::MulticoreParam(workers = nCores_inner, RNGseed = task_seed)
norm_mat <- t(scale(t(mat)))
rf <- JRF::JRF(X = list(norm_mat),
genes.name = rownames(norm_mat),
ntree = 500,
mtry = round(sqrt(nrow(norm_mat) - 1)))
rf
}
}, BPPARAM = param_outer)
}
#'
#' Sets the Python path and imports required Python modules (arboreto, pandas, numpy)
#' for running GRNBoost2.
#'
#' @param python_path Path to the Python executable (e.g., "/usr/bin/python3").
#' @param required Logical. If TRUE, throws an error if Python is not available.
#'
#' @return A list containing Python modules: arboreto, pandas, and numpy.
#'
#' @export
init_py <- function(python_path = "/usr/bin/python3", required = TRUE) {
reticulate::use_python(python_path, required = required)
modules <- list(
arboreto = reticulate::import("arboreto.algo", delay_load = TRUE),
pandas   = reticulate::import("pandas", delay_load = TRUE),
numpy    = reticulate::import("numpy", delay_load = TRUE)
)
message("Python modules successfully loaded.")
return(modules)
}
modules <- init_py(python_path ="/usr/bin/python3", required = TRUE)
# GRNBoost2
## Late integration
time[["GRNBoost2_late"]] <- system.time(
late <- infer_networks(count_matrices,
method="GRNBoost2",
grnboost_modules = modules,
total_cores = 15,
seed=seed_base+run_id)
)
slate_adj <- cutoff_adjacency(count_matrices = count_matrices,
weighted_adjm_list = slate_wadj,
n = 3,
method = "GRNBoost2",
grnboost_modules = modules)
cutoff_adjacency <- function(count_matrices,
weighted_adjm_list,
n,
method = "GENIE3",
quantile_threshold = 0.99,
weight_function = "mean",
total_cores = BiocParallel::bpworkers(BiocParallel::bpparam()),
grnboost_modules = NULL,
seed = 123,
debug = FALSE) {
method <- match.arg(method, choices = c("GENIE3", "GRNBoost2", "JRF"))
weight_function <- match.fun(weight_function)
if (length(count_matrices) != length(weighted_adjm_list)) {
stop("Length of count_matrices must match weighted_adjm_list.")
}
# Prepare expression matrices
count_matrices <- lapply(count_matrices, function(obj) {
if (inherits(obj, "Seurat")) {
as.matrix(Seurat::GetAssayData(obj, assay = "RNA", slot = "counts"))
} else if (inherits(obj, "SingleCellExperiment")) {
as.matrix(SummarizedExperiment::assay(obj, "counts"))
} else {
as.matrix(obj)
}
})
shuffle_rows <- function(matrix, seed_vector) {
shuffled <- matrix
for (i in seq_len(nrow(matrix))) {
set.seed(seed_vector[i])
shuffled[i, ] <- sample(matrix[i, ])
}
shuffled
}
create_shuffled_matrices <- function(mat, n, base_seed) {
lapply(seq_len(n), function(i) {
seed_vector <- sample(base_seed + i + seq_len(nrow(mat)))
shuffle_rows(mat, seed_vector)
})
}
# Define total jobs (k matrices × n shuffles)
job_list <- expand.grid(matrix_idx = seq_along(count_matrices), shuffle_idx = seq_len(n))
job_list <- lapply(seq_len(nrow(job_list)), function(i) {
list(matrix_idx = job_list$matrix_idx[i], shuffle_idx = job_list$shuffle_idx[i])
})
# Parallel strategy
nCores_outer <- min(total_cores, length(job_list))
nCores_inner <- max(floor(total_cores / nCores_outer), 1)
param_outer <- if (method == "GRNBoost2") {
BiocParallel::SerialParam()
} else {
BiocParallel::MulticoreParam(workers = nCores_outer, RNGseed = seed)
}
percentile_values_by_matrix <- vector("list", length(count_matrices))
results <- BiocParallel::bplapply(job_list, function(job) {
mat_idx <- job$matrix_idx
shuf_idx <- job$shuffle_idx
mat <- count_matrices[[mat_idx]]
base_seed <- as.integer(round(seed * 1000 + mat_idx * 10 + shuf_idx))
shuffled <- create_shuffled_matrices(mat, 1, base_seed)[[1]]
args <- list(count_matrices_list = list(shuffled), method = method, adjm = NULL, seed = base_seed)
if (method == "GENIE3") {
args$total_cores <- nCores_inner
}
if (method == "GRNBoost2") {
args$grnboost_modules <- grnboost_modules
args$total_cores <- nCores_inner
}
inferred <- do.call(infer_networks, args)
adjm <- generate_adjacency(inferred)
symm <- symmetrize(adjm, weight_function = weight_function)[[1]]
q_value <- quantile(symm[upper.tri(symm)], quantile_threshold, names = FALSE)
list(matrix_idx = mat_idx, q_value = q_value)
}, BPPARAM = param_outer)
# Aggregate results by matrix
for (res in results) {
mat_idx <- res$matrix_idx
percentile_values_by_matrix[[mat_idx]] <- c(percentile_values_by_matrix[[mat_idx]], res$q_value)
}
binary_adjm_list <- lapply(seq_along(weighted_adjm_list), function(idx) {
avg_cutoff <- mean(percentile_values_by_matrix[[idx]])
if (debug) message(sprintf("[Method: %s] Matrix %d → Cutoff = %.5f", method, idx, avg_cutoff))
ifelse(weighted_adjm_list[[idx]] > avg_cutoff, 1, 0)
})
return(binary_adjm_list)
}
slate_adj <- cutoff_adjacency(count_matrices = count_matrices,
weighted_adjm_list = slate_wadj,
n = 3,
method = "GRNBoost2",
grnboost_modules = modules)
scores.late.all <- pscores(adjm, slate_adj)
df <- as.data.frame(t(count_matrices[[1]]))
head(df)
df_pandas <- grnboost_modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes,
index = rownames(df)
)
df_pandas <- modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes,
index = rownames(df)
)
genes <- colnames(df)
df_pandas <- grnboost_modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes,
index = rownames(df)
)
df_pandas <- modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes,
index = rownames(df)
)
df_pandas
result_py <- modules$arboreto$grnboost2(
expression_data = df_pandas,
gene_names = genes
)
rownames(df_pandas)
colnames(df_pandas)
unique(length(df_pandas))
unique(length(colnames(df_pandas)))
unique(length(rownames(df_pandas)))
result_py <- modules$arboreto$grnboost2(
expression_data = df_pandas,
gene_names = genes
)
df_pandas
df_pandas <- modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes
)
head(df_pandas)
df_pandas <- modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes,
)
df_pandas <- modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes, index=rownames(df)
)
head(df_pandas)
df_pandas <- grnboost_modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes)
df_pandas <- modules$pandas$DataFrame(
data = as.matrix(df),
columns = genes
)
result_py <- modules$arboreto$grnboost2(
expression_data = df_pandas,
gene_names = genes
)
rownames(df_pandas)
