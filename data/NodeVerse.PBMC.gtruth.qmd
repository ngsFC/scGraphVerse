---
title: "NodeVerse PBMC Data and Ground Truth"
author: "Francesco Cecere"
date: "`r Sys.Date()`"
format: 
  html:
    code-fold: true  # Collapse code blocks
    toc: true        # Table of contents
    toc-depth: 2     # Depth of TOC headings
    toc-location: left
    number-sections: true
    theme: minty # Use a predefined theme
    smooth-scroll: true  # Enable smooth scrolling
    code-summary: "Show the Code"  # Custom label for code folding
    highlight-style: github # Syntax highlighting style
    link-external-newwindow: true  # Open external links in a new window
editor: visual
execute:
  warning: false  # Suppress warnings globally
  message: false  # Suppress package messages globally
  error: false    # Prevent the document from halting on errors
---

## Load Libraries

```{r load-libraries}
knitr::opts_knit$set(root.dir = "/home/francescoc/Desktop/NodeVerse/data")

library(biomaRt)
library(DT)
library(tidyverse)
library(Seurat)
library(STRINGdb)

library(NodeVerse)
```

## Load BioGRID Data

```{r Download and format BioGRID data}
#biogrid_data <- read.delim("/home/francescoc/Downloads/BIOGRID-ALL-4.4.241.tab3.txt", header = TRUE, stringsAsFactors = FALSE)

#biogrid_data <- biogrid_data[, c("Official.Symbol.Interactor.A", 
#                                 "Official.Symbol.Interactor.B", 
#                                 "Score",
#                                 "Experimental.System.Type",
#                                 "Organism.Name.Interactor.A",
#                                 "Organism.Name.Interactor.B")]
#names(biogrid_data) <- c("Interactor_A", "Interactor_B", "Score", "type", "org1", "org2")

#biogrid_data <- biogrid_data %>%
#  mutate(Score = as.numeric(Score)) %>%
#  filter(type == "physical") %>%       
#  filter(!is.na(Score)) %>%            
#  filter(abs(Score) > 300) %>%
#  filter(org1 == "Homo sapiens" & org2 == "Homo sapiens")

#write.table(biogrid_data, "biogrid_physical_s300-ALL-4.4.242.txt", sep = "\t", quote = FALSE, col.names = TRUE, row.names = TRUE)

#biogrid_data %>%
#    datatable(extensions = 'Buttons',
#            options = list(
#              dom = 'Bfrtip',
#              buttons = c('csv', 'excel'),
#              scrollX = TRUE,
#              pageLength = 10), 
#            caption = "BioGRID data")

```

## Load Atlas Data

```{r Download Seurat Object}
options(timeout = 600)

# PBMC Dataset: Local and systemic responses to SARS-CoV-2 infection in children and adults
seurat_url <- "https://datasets.cellxgene.cziscience.com/89619149-162f-4839-8e97-24735924417c.rds"

seurat_object <- download_Atlas(seurat_url)

seurat_subset <- subset(
  x = seurat_object,
  subset = disease == "normal" & cell_type == "CD4-positive helper T cell" & donor_id %in% c("AN6", "AN9", "NP18")
)

```

```{r Filter Seurat object}
meta_features <- seurat_subset[["RNA"]]@meta.features
stopifnot(all(rownames(meta_features) == rownames(seurat_subset[["RNA"]]@data)))

new_rownames <- meta_features$name
new_rownames <- seurat_subset@assays$RNA@meta.features$name

if (length(new_rownames) != nrow(seurat_subset[["RNA"]]@data)) {
  stop("The length of new_rownames does not match the number of features.")
}

assay <- seurat_subset[["RNA"]] # Access the RNA assay
rownames(assay@counts) <- new_rownames
rownames(assay@data) <- new_rownames
rownames(assay@meta.features) <- new_rownames

seurat_subset[["RNA"]] <- assay

```

## Filtering step

```{r}
seurat_subset <- PercentageFeatureSet(seurat_subset, "^MT-", col.name = "percent_mito")
# Ribosomal
seurat_subset <- PercentageFeatureSet(seurat_subset, "^RP[SL]", col.name = "percent_ribo")

feats <- c("nFeature_RNA", "nCount_RNA", "percent_mito", "percent_ribo")
VlnPlot(seurat_subset, group.by = "donor_id", split.by = "donor_id", features = feats, pt.size = 0.1, ncol = 3)
FeatureScatter(seurat_subset, "nCount_RNA", "nFeature_RNA", group.by = "donor_id", pt.size = .5)
```

```{r}
selected_c <- WhichCells(seurat_subset, expression = nFeature_RNA > 200)
selected_f <- rownames(seurat_subset)[Matrix::rowSums(seurat_subset) > 3]

seurat_subset_filt <- subset(seurat_subset, features = selected_f, cells = selected_c)
dim(seurat_subset_filt)
table(seurat_subset_filt$donor_id)

C <- seurat_subset_filt@assays$RNA@counts
C@x <- C@x / rep.int(colSums(C), diff(C@p)) * 100
most_expressed <- order(Matrix::rowSums(C), decreasing = T)[20:1]
boxplot(as.matrix(t(C[most_expressed, ])),
    cex = 0.1, las = 1, xlab = "Percent counts per cell",
    col = (scales::hue_pal())(20)[20:1], horizontal = TRUE
)
```

```{r}
selected_mito <- WhichCells(seurat_subset_filt, expression = percent_mito < 20)
selected_ribo <- WhichCells(seurat_subset_filt, expression = percent_ribo > 5)

# and subset the object to only keep those cells
seurat_subset_filt <- subset(seurat_subset_filt, cells = selected_mito)
seurat_subset_filt <- subset(seurat_subset_filt, cells = selected_ribo)
dim(seurat_subset_filt)

feats <- c("nFeature_RNA", "nCount_RNA", "percent_mito", "percent_ribo")
VlnPlot(seurat_subset_filt, group.by = "donor_id", features = feats, pt.size = 0.1, ncol = 3) + NoLegend()

```

```{r}
# Filter MALAT1
seurat_subset_filt <- seurat_subset_filt[!grepl("MALAT1", rownames(seurat_subset_filt)), ]

# Filter Mitocondrial
seurat_subset_filt <- seurat_subset_filt[!grepl("^MT-", rownames(seurat_subset_filt)), ]

# Filter Ribossomal gene (optional if that is a problem on your data)
seurat_subset_filt <- seurat_subset_filt[ ! grepl("^RP[SL]", rownames(seurat_subset_filt)), ]

dim(seurat_subset_filt)
C <- seurat_subset_filt@assays$RNA@counts
C@x <- C@x / rep.int(colSums(C), diff(C@p)) * 100
most_expressed <- order(Matrix::rowSums(C), decreasing = T)[20:1]
boxplot(as.matrix(t(C[most_expressed, ])),
    cex = 0.1, las = 1, xlab = "Percent counts per cell",
    col = (scales::hue_pal())(20)[20:1], horizontal = TRUE
)
```

## Adjacency matrix

```{r Generate Adjacency matrice}

pathgenes <- pathg(seurat_object = seurat_subset_filt, cell_type = "CD4-positive helper T cell", top_n = 1000)

options(timeout = 2000)
result <- stringdb_adjacency(
  genes          = pathgenes,
  species        = 9606,
  required_score = 900,
  keep_all_genes = F
)

wadjm <- result$weighted
adjm <- result$binary

common_names <- intersect(rownames(adjm), colnames(adjm))
adjm <- adjm[common_names, common_names, drop = FALSE]

sorted_names <- sort(rownames(adjm))
adjm <- adjm[sorted_names, sorted_names]

print(dim(wadjm))
print(dim(adjm))

write.table(adjm, "./../analysis/adjm_p677.txt", sep = "\t", quote = FALSE, col.names = TRUE, row.names = TRUE)
write.table(wadjm, "./../analysis/wadjm_p677.txt", sep = "\t", quote = FALSE, col.names = TRUE, row.names = TRUE)

wadjm %>%
    datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "BioGRID Adjacency Top1000 genes")

adjm %>%
    datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "BioGRID Adjacency Top1000 genes")

```

## Split data for donor_id

```{r format control Seurat data}
genes_to_keep <- intersect(pathgenes, rownames(seurat_subset_filt))
seurat_subset_filt <- subset(seurat_subset_filt, features = genes_to_keep)

saveRDS(seurat_subset_filt, "PBMC.top1000.RDS")
```

## Create Ground Truth Network

```{r plot Ground truth}
gtruth <- igraph::graph_from_adjacency_matrix(adjm, mode = "undirected", diag = FALSE)

num_nodes <- igraph::vcount(gtruth)
num_edges <- igraph::ecount(gtruth)

set.seed(1234)

p1 <- ggraph::ggraph(gtruth, layout = "fr") + 
  ggraph::geom_edge_link(color = "gray", width = 0.5) +  # Set edge color and width
  ggraph::geom_node_point(color = "steelblue", size = 0.7) +  # Set node color and size
  labs(title = paste("Ground Truth\nNodes:", igraph::vcount(gtruth), "Edges:", igraph::ecount(gtruth))) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  )

p1

ggsave("./../analysis/gtruth_top1000_s300.png", p1, width = 8, height = 6, dpi = 300, bg = "white")
```

## Simulate n500 p677 matrices

```{r Simulate k matrices with n cells (500) and p genes}
ncell <- 500
nodes <- nrow(adjm)

set.seed(1130)
mu_values <- c(3, 6, 9)
theta_values <- c(1, 0.7, 0.5)

count_matrices <- lapply(1:3, function(i) {
  set.seed(1130 + i)
  mu_i <- mu_values[i]
  theta_i <- theta_values[i]
  
  count_matrix_i <- learn2count::simdata(n = ncell, p = nodes, B = adjm, family = "ZINB", 
                            mu = mu_i, mu_noise = 1, theta = theta_i, pi = 0.2)
  
  count_matrix_df <- as.data.frame(count_matrix_i)
  colnames(count_matrix_df) <- colnames(adjm)
  rownames(count_matrix_df) <- paste("cell", 1:nrow(count_matrix_df), sep = "")
  
  return(count_matrix_df)
})

saveRDS(count_matrices, "./../analysis/sim_n500p677.RDS")

count_matrices[[1]] %>%
    datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "Simulated Matrix")

```

```{r}
#' Generate zero-inflated negative binomial data
#'
#' Simulate zero-inflated negative binomial (ZINB) data based on an adjacency matrix.
#'
#' # Parameters:
#' # n: Integer. Number of samples.
#' # p: Integer. Number of variables (nodes).
#' # B: Matrix. Symmetric adjacency matrix (binary: 0/1), with row and column names as gene names.
#' # mu_range: Numeric vector of length 2. Range for mu values (e.g., c(5, 15)).
#' # mu_noise: Numeric. Mean of the noise component.
#' # theta: Numeric. Dispersion parameter of the negative binomial part.
#' # pi: Numeric. Probability of excess zeros (0 < pi < 1).
#' # seed: Integer (optional). Random seed for reproducibility.
#'
#' @importFrom countreg rzinbinom
#' @return A numeric matrix of dimension n x p, where row names correspond to gene names from B.
zinb_simdata <- function(n, p, B, mu_range, mu_noise, theta, pi, seed = NULL) {
  
  if (!is.numeric(n) || n <= 0 || floor(n) != n) stop("n must be a positive integer.")
  if (!is.numeric(p) || p <= 0 || floor(p) != p) stop("p must be a positive integer.")
  if (!is.matrix(B) || nrow(B) != ncol(B)) stop("B must be a square matrix.")
  if (!all(B %in% c(0, 1))) stop("B must contain only 0s and 1s.")
  if (!is.numeric(mu_range) || length(mu_range) != 2 || any(mu_range <= 0)) stop("mu_range must be a numeric vector of length 2 with positive values.")
  if (!is.numeric(mu_noise) || mu_noise < 0) stop("mu_noise must be non-negative.")
  if (!is.numeric(theta) || theta <= 0) stop("theta must be a positive number.")
  if (!is.numeric(pi) || pi <= 0 || pi >= 1) stop("pi must be in the range (0,1).")
  if (!is.null(seed) && (!is.numeric(seed) || length(seed) != 1 || floor(seed) != seed)) stop("seed must be a single integer.")
  
  if (!is.null(seed)) set.seed(seed)
  gene_names <- rownames(B)
  cellID <- paste("cell_", seq(1:n), sep = "")
  
  B <- ifelse(B > 0, 1, 0)
  
  # Generate mu as a random vector of length p from the given range
  mu <- sample(seq(mu_range[1], mu_range[2]), p, replace = TRUE)
  
  A <- diag(1, nrow = p, ncol = p)
  edges <- which(B == 1, arr.ind = TRUE)
  edges <- edges[edges[, 1] < edges[, 2], ]  # Remdup
  
  for (i in seq_len(nrow(edges))) {
    tmp <- numeric(p)
    tmp[edges[i, ]] <- 1
    A <- cbind(A, tmp)
  }
  
  B[edges] <- sample(seq(mu_range[1], mu_range[2]), length(edges[, 1]), replace = TRUE)
  B <- (B + t(B)) / 2  # symmetry
  
  sigma <- B  
  nonzero_sigma <- sigma[lower.tri(sigma) & sigma != 0]
  Y_mu <- c(mu, nonzero_sigma)  
  
  # Generate ZINB data
  Y <- matrix(rzinbinom(length(Y_mu) * n, mu = rep(Y_mu, each = n), theta = theta, pi = pi), 
              nrow = length(Y_mu), ncol = n)
  
  X <- A %*% Y
  noise_matrix <- matrix(rzinbinom(n * p, mu = mu_noise, theta = 1, pi = pi), nrow = p, ncol = n)
  X <- X + noise_matrix
  
  X <- t(X)
  if (!is.null(gene_names)) colnames(X) <- gene_names
  if (!is.null(cellID)) rownames(X) <- cellID
  
  return(X)
}
```

```{r}
library(distributions3)
m1 <- zinb_simdata(ncell, nodes, adjm, mu_range = c(2,15), mu_noise = 1, theta = 1, pi = 0.2)
m2 <- zinb_simdata(ncell, nodes, adjm, mu_range = c(2,15), mu_noise = 1, theta = 1, pi = 0.2)
m3 <- zinb_simdata(ncell, nodes, adjm, mu_range = c(2,15), mu_noise = 1, theta = 1, pi = 0.2)

saveRDS(list(m1,m2,m3), "./../analysis/sim_n500p677.RDS")

```
