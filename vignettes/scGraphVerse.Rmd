---
title: "Getting Started with scGraphVerse"
author: "Francesco Cecere"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Getting Started with scGraphVerse}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Bioconductor compliance

**scGraphVerse** is distributed through Bioconductor; it adheres to the [Bioconductor package guidelines](https://bioconductor.org/developers/package-guidelines/) for documentation, versioning, and testing.  Please make sure to run `BiocCheck::BiocCheck()` before submission, include unit tests under `tests/`, and follow the code‐of‐conduct.

## Introduction

Single‐cell RNA‐seq has opened new doors for reconstructing cell‐type‐specific gene regulatory networks (GRNs).  *scGraphVerse* provides a streamlined workflow to:

1.  Simulate single‐cell count data (including zero‐inflation) via the ZILGM framework[^ZILGM]  
2.  Infer GRNs with multiple algorithms:  
    -  **GENIE3**[^GENIE3]  
    -  **GRNBoost2**[^GRNBoost2]  
    -  **JRF**[^JRF]  
3.  Evaluate performance against a ground‐truth network  
4.  Build consensus networks and explore network communities  

Throughout this vignette we’ll highlight the core functions and point you to the original method papers.

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(scGraphVerse)
library(Seurat)
library(tidyverse)
```

## Load and Pre‐process a Public Dataset
We start by downloading a PBMC dataset from the CellxGene atlas, subsetting to healthy CD4⁺ T cells, and applying standard QC filters (mitochondrial, ribosomal, feature and count thresholds).


```{r}
options(timeout = 2000)

# 1. Download the Seurat object
seurat_url <- "https://datasets.cellxgene.cziscience.com/42e24d96-69c6-4f05-8237-b5d305c49b45.h5ad"
seurat_url <- "https://datasets.cellxgene.cziscience.com/84bf2cf0-1944-499e-a22e-fe998f6198b2.h5ad"

seurat_url <- "https://datasets.cellxgene.cziscience.com/fb338c4d-e63a-4b17-abd6-1032a66c8886.h5ad"

seurat_object <- download_Atlas(url=seurat_url, output="sce")

seurat_object <- download_Atlas_sparse(url=seurat_url, output="seurat")
```

## Define a “Ground‐Truth” Regulatory Network
We use high‐confidence STRINGdb edges as our ground truth. You can substitute any known adjacency matrix here.


```{r}
# 1. Select top variable genes
pathgenes <- selgene(
  object = seurat_object,
  top_n  = 500
)

# 2. Query STRINGdb for high‐confidence edges
result <- stringdb_adjacency(
  genes          = pathgenes,
  species        = 9606,
  required_score = 900,
  keep_all_genes = FALSE
)
wadj <- result$weighted
adj <- result$binary

# 3. Symmetrize and sort
common <- intersect(rownames(adj), colnames(adj))
adj <- adj[common, common]
adj <- adj[sort(rownames(adj)), sort(colnames(adj))]

# 4. Visualize
gtruth <- igraph::graph_from_adjacency_matrix(adj, mode = "undirected")
ggraph::ggraph(gtruth, layout = "fr") +
  ggraph::geom_edge_link(color = "gray") +
  ggraph::geom_node_point(color = "steelblue") +
  ggtitle(
    paste0(
      "Ground Truth: ", igraph::vcount(gtruth), " nodes, ",
      igraph::ecount(gtruth), " edges"
    )
  ) + theme_minimal()
```

## Simulate Zero‐Inflated Count Data
We leverage a zero‐inflated network‐aware simulator based on the ZILGM framework1, which retains the ground‐truth dependencies in the counts.


```{r}
nodes <- nrow(adj)
b <- 3
sigma <- 0.2

count_matrices <- zinb_simdata(
  n = 50,
  p = nodes,
  B = adj,
  mu_range = list(c(1, 4), c(1, 7), c(1, 10)),
  mu_noise = c(1, 3, 5),
  theta = c(1, 0.7, 0.5),
  pi = c(0.2, 0.2, 0.2),
  kmat = 3,
  depth_range = c(round((1 - sigma) * nodes * b), round((1 + sigma) * nodes * b))
)

# Transpose each to cells × genes
count_matrices <- lapply(count_matrices, t)
```

## Infer Networks with Multiple Algorithms
### GENIE3


```{r}
late_genie3 <- infer_networks(
  count_matrices,
  method      = "GENIE3",
  total_cores = 15,
  seed        = 1234
)
```


```{r}
sessionInfo()
```

