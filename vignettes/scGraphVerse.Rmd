---
title: "Getting Started with scGraphVerse"
author: "Francesco Cecere"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Getting Started with scGraphVerse}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Bioconductor compliance

**scGraphVerse** is distributed through Bioconductor; it adheres to the [Bioconductor package guidelines](https://bioconductor.org/developers/package-guidelines/) for documentation, versioning, and testing.  Please make sure to run `BiocCheck::BiocCheck()` before submission, include unit tests under `tests/`, and follow the code‐of‐conduct.

## Introduction

Single‐cell RNA‐seq has opened new doors for reconstructing cell‐type‐specific gene regulatory networks (GRNs).  *scGraphVerse* provides a streamlined workflow to:

1.  Simulate single‐cell count data (including zero‐inflation) via the ZILGM framework[^ZILGM]  
2.  Infer GRNs with multiple algorithms:  
    -  **GENIE3**[^GENIE3]  
    -  **GRNBoost2**[^GRNBoost2]  
    -  **JRF**[^JRF]  
3.  Evaluate performance against a ground‐truth network  
4.  Build consensus networks and explore network communities  

Throughout this vignette we’ll highlight the core functions and point you to the original method papers.

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(scGraphVerse)
library(Seurat)
library(tidyverse)
```

## Load and Pre‐process a Public Dataset
We start by downloading a PBMC dataset from the CellxGene atlas, subsetting to healthy CD4⁺ T cells, and applying standard QC filters (mitochondrial, ribosomal, feature and count thresholds).


```{r}
options(timeout = 600)

# 1. Download the Seurat object
seurat_url <- "https://datasets.cellxgene.cziscience.com/89619149-162f-4839-8e97-24735924417c.rds"
seurat_object <- download_Atlas(seurat_url)

# 2. Subset to normal CD4+ helper T cells
seurat_subset <- subset(
  x = seurat_object,
  subset = disease == "normal" &
    cell_type == "CD4-positive helper T cell" &
    donor_id %in% c("AN6", "AN9", "NP18")
)

# 3. Rename gene IDs to gene symbols
meta_features <- seurat_subset[["RNA"]]@meta.features
new_rownames <- meta_features$name
assay <- seurat_subset[["RNA"]]
rownames(assay@counts) <- new_rownames
rownames(assay@data) <- new_rownames
rownames(assay@meta.features) <- new_rownames
seurat_subset[["RNA"]] <- assay

# 4. QC: features > 200, expression sum > 3, % mito < 20, etc.
selected_cells <- WhichCells(seurat_subset, expression = nFeature_RNA > 200)
selected_genes <- rownames(seurat_subset)[Matrix::rowSums(seurat_subset) > 3]
seurat_subset <- subset(seurat_subset, features = selected_genes, cells = selected_cells)
seurat_subset <- PercentageFeatureSet(seurat_subset, "^MT-", col.name = "percent_mito")
seurat_subset <- PercentageFeatureSet(seurat_subset, "^RP[SL]", col.name = "percent_ribo")
seurat_subset <- subset(seurat_subset, subset = percent_mito < 20 & percent_ribo > 5)

# 5. Remove MALAT1, mitochondrial and ribosomal genes
seurat_subset <- seurat_subset[!grepl("MALAT1", rownames(seurat_subset)), ]
seurat_subset <- seurat_subset[!grepl("^MT-", rownames(seurat_subset)), ]
seurat_subset <- seurat_subset[!grepl("^RP[SL]", rownames(seurat_subset)), ]
```

## Define a “Ground‐Truth” Regulatory Network
We use high‐confidence STRINGdb edges as our ground truth. You can substitute any known adjacency matrix here.


```{r}
# 1. Select top variable genes
pathgenes <- selgene(
  seurat_object = seurat_subset,
  cell_type     = "CD4-positive helper T cell",
  top_n         = 500
)

# 2. Query STRINGdb for high‐confidence edges
result <- stringdb_adjacency(
  genes          = pathgenes,
  species        = 9606,
  required_score = 900,
  keep_all_genes = FALSE
)
wadj <- result$weighted
adj <- result$binary

# 3. Symmetrize and sort
common <- intersect(rownames(adj), colnames(adj))
adj <- adj[common, common]
adj <- adj[sort(rownames(adj)), sort(colnames(adj))]

# 4. Visualize
gtruth <- igraph::graph_from_adjacency_matrix(adj, mode = "undirected")
ggraph::ggraph(gtruth, layout = "fr") +
  ggraph::geom_edge_link(color = "gray") +
  ggraph::geom_node_point(color = "steelblue") +
  ggtitle(
    paste0(
      "Ground Truth: ", igraph::vcount(gtruth), " nodes, ",
      igraph::ecount(gtruth), " edges"
    )
  ) + theme_minimal()
```

## Simulate Zero‐Inflated Count Data
We leverage a zero‐inflated network‐aware simulator based on the ZILGM framework1, which retains the ground‐truth dependencies in the counts.


```{r}
nodes <- nrow(adj)
b <- 3
sigma <- 0.2

count_matrices <- zinb_simdata(
  n = 50,
  p = nodes,
  B = adj,
  mu_range = list(c(1, 4), c(1, 7), c(1, 10)),
  mu_noise = c(1, 3, 5),
  theta = c(1, 0.7, 0.5),
  pi = c(0.2, 0.2, 0.2),
  kmat = 3,
  depth_range = c(round((1 - sigma) * nodes * b), round((1 + sigma) * nodes * b))
)

# Transpose each to cells × genes
count_matrices <- lapply(count_matrices, t)
```

## Infer Networks with Multiple Algorithms
### GENIE3


```{r}
late_genie3 <- infer_networks(
  count_matrices,
  method      = "GENIE3",
  total_cores = 15,
  seed        = 1234
)
```


```{r}
sessionInfo()
```

