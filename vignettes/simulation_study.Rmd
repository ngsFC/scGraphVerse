---
title: "Getting Started with scGraphVerse"
author: "Francesco Cecere"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Getting Started with scGraphVerse}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Bioconductor compliance

**scGraphVerse** is distributed through Bioconductor; it adheres to the [Bioconductor package guidelines](https://bioconductor.org/developers/package-guidelines/) for documentation, versioning, and testing.  Please make sure to run `BiocCheck::BiocCheck()` before submission, include unit tests under `tests/`, and follow the code‐of‐conduct.

## Introduction

Single‐cell RNA‐seq has opened new doors for reconstructing cell‐type‐specific gene regulatory networks (GRNs).  *scGraphVerse* provides a streamlined workflow to:

1.  Simulate single‐cell count data (including zero‐inflation) via the ZILGM framework[^ZILGM]  
2.  Infer GRNs with multiple algorithms:  
    -  **GENIE3**[^GENIE3]  
    -  **GRNBoost2**[^GRNBoost2]  
    -  **JRF**[^JRF]  
3.  Evaluate performance against a ground‐truth network  
4.  Build consensus networks and explore network communities  

Throughout this vignette we’ll highlight the core functions and point you to the original method papers.

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(scGraphVerse)
library(Seurat)
library(tidyverse)
```

## Load and Pre‐process a Public Dataset
We start by downloading a PBMC dataset from the CellxGene atlas, subsetting to healthy CD4⁺ T cells, and applying standard QC filters (mitochondrial, ribosomal, feature and count thresholds).


```{r}
# options(timeout = 2000)

# 1. Download the Seurat object
dataset_url <- "https://www.dropbox.com/s/r8qwsng79rhp9gf/SCA_scRNASEQ_TISSUE_WHOLE_BLOOD.RDS?dl=1"
sc_object <- download_Atlas(file_url = dataset_url)
```

## Define a “Ground‐Truth” Regulatory Network
We use high‐confidence STRINGdb edges as our ground truth. You can substitute any known adjacency matrix here.


```{r}
# 1. Select top variable genes
pathgenes <- selgene(
  object = sc_object,
  top_n = 500,
  cell_type = "T_cells",
  cell_type_col = "CELL_TYPE",
  remove_rib = TRUE,
  remove_mt = TRUE
)

# 2. Query STRINGdb for high‐confidence edges
result <- stringdb_adjacency(
  genes          = pathgenes,
  species        = 9606,
  required_score = 900,
  keep_all_genes = FALSE
)

wadj <- result$weighted
adj <- result$binary

# 3. Symmetrize and sort
common <- intersect(rownames(adj), colnames(adj))
adj <- adj[common, common]
adj <- adj[sort(rownames(adj)), sort(colnames(adj))]

# 4. Visualize
gtruth <- igraph::graph_from_adjacency_matrix(adj, mode = "undirected")
ggraph::ggraph(gtruth, layout = "fr") +
  ggraph::geom_edge_link(color = "gray") +
  ggraph::geom_node_point(color = "steelblue") +
  ggtitle(
    paste0(
      "Ground Truth: ", igraph::vcount(gtruth), " nodes, ",
      igraph::ecount(gtruth), " edges"
    )
  ) + theme_minimal()
```

## Simulate Zero‐Inflated Count Data
We leverage a zero‐inflated network‐aware simulator based on the ZILGM framework1, which retains the ground‐truth dependencies in the counts.

```{r}
nodes <- nrow(adj)
b <- 3
sigma <- 0.2

count_matrices <- zinb_simdata(
  n = 50,
  p = nodes,
  B = adj,
  mu_range = list(c(1, 4), c(1, 7), c(1, 10)),
  mu_noise = c(1, 3, 5),
  theta = c(1, 0.7, 0.5),
  pi = c(0.2, 0.2, 0.2),
  kmat = 3,
  depth_range = c(round((1 - sigma) * nodes * b), round((1 + sigma) * nodes * b))
)

# Transpose each to cells × genes
count_matrices <- lapply(count_matrices, t)
```

## Infer Networks with Multiple Algorithms

```{r}
#networks_late <- infer_networks(
#  count_matrices,
#  method = "GENIE3",
#  nCores = 15
#)

#list_wadj <- generate_adjacency(networks_late)
#list_swadj <- symmetrize(list_wadj, weight_function = "mean")

#binary_adjm_list <- cutoff_adjacency(
#  count_matrices = count_matrices,
#  weighted_adjm_list = list_swadj,
#  n = 2,
#  method = "GENIE3",
#  quantile_threshold = 0.95,
#  nCores = 15,
#  debug = TRUE
#)
```

```{r}
#earlym <- list(earlyj(count_matrices))
#networks_early <- infer_networks(
#  earlym,
#  method = "GENIE3",
#  nCores = 15
#)

#list_wadj <- generate_adjacency(networks_early)
#list_swadj <- symmetrize(list_wadj, weight_function = "mean")

#binary_adjm_list_early <- cutoff_adjacency(
#  count_matrices = earlym,
#  weighted_adjm_list = list_swadj,
#  n = 2,
#  method = "GENIE3",
#  quantile_threshold = 0.95,
#  nCores = 15,
#  debug = TRUE
#)
```


```{r}
networks_joint <- infer_networks(
  count_matrices_list = count_matrices,
  method = "JRF",
  nCores = 15
)

list_wadjj <- generate_adjacency(networks_joint)
list_swadjj <- symmetrize(list_wadjj, weight_function = "mean")

binary_adjm_listj <- cutoff_adjacency(
  count_matrices = count_matrices,
  weighted_adjm_list = list_swadjj,
  n = 2,
  method = "JRF",
  quantile_threshold = 0.95,
  nCores = 15,
  debug = TRUE
)

```

```{r}
joint_auc <- plotROC(list_swadjj, adj, plot_title = "ROC curve - JRF Joint Integration", is_binary = F)
joint_auc$plot
```

```{r}
scores.joint <- pscores(adj, binary_adjm_listj)
plotg(binary_adjm_listj)
```

```{r}
consesusm <- create_consensus(binary_adjm_listj, method="vote")
plotg(list(consesusm))

compare_consensus(consensus_matrix = consesusm, reference_matrix = adj, false_plot = F)
scores.vote <- pscores(adj, list(consesusm))
```

```{r}
adj_comm <- community_path(adj)
comm_consesusm <- community_path(consesusm)
topscore <- community_similarity(adj_comm,list(comm_consesusm, comm_consesusu, comm_consesunet)) 
```

```{r}
sessionInfo()
```
