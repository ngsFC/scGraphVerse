library("rmarkdown")
library("kableExtra")
library("reshape")
library("gridExtra")
library("grid")
library("ggpubr")
library("valr")
library("IlluminaHumanMethylationEPICanno.ilm10b4.hg19")
library("IlluminaHumanMethylationEPICmanifest")
library("patchwork")
methylationarray <- "EPIC"
norm <- "BMIQ"
testDir <- "/home/francescoc/Desktop/Project/Merla_lab/Marray_Merla"
breaksList1 <- seq(-0.5, 0.5, by = 0.01)
breaksList <- seq(0, 1, by = 0.01)
annEPIC <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
bedEPIC <- as.data.frame(annEPIC) %>%
rownames_to_column("probeID") %>%
dplyr::select(chr, pos, probeID) %>%
mutate(end = pos) %>%
relocate(end, .after = pos)
colnames(bedEPIC) <- c("chrom", "start", "end", "probeID")
annotation <- data.frame(rownames(annEPIC), annEPIC$UCSC_RefGene_Name, annEPIC$UCSC_RefGene_Group)
colnames(annotation) <- c("probeID", "Gene", "feature")
all.genes <- annotation %>%
dplyr::select(Gene, feature) %>%
separate_rows(Gene, feature, sep = ";")
all.genes.TSS <- annotation %>%
filter(grepl("TSS200", feature) | grepl("TSS1500", feature))
all.genes.TSS <- all.genes.TSS %>%
dplyr::select(Gene, feature) %>%
separate_rows(Gene, feature, sep = ";") %>%
filter(feature == "TSS200" | feature == "TSS1500")
bg.genes <- unique(all.genes$Gene)
bg.genes.TSS <- unique(all.genes.TSS$Gene)
myLoad <- champ.load(testDir,
method="ChAMP",
methValue="B",
autoimpute=TRUE,
filterDetP=TRUE,
ProbeCutoff=0,
SampleCutoff=0.1,
detPcut=0.01,
filterBeads=TRUE,
beadCutoff=0.05,
filterNoCG=TRUE,
filterSNPs=TRUE,
population=NULL,
filterMultiHit=TRUE,
filterXY=TRUE,
force=FALSE,
arraytype=methylationarray)
ann.column <- data.frame(Sample = myLoad$pd$Sample_Group,
Syndrome = myLoad$pd$Syndrome)
rownames(ann.column) <- myLoad$pd$Sample_Name
samplecolor <- list(Sample = c(Control = "Grey", Case = "Steel blue"),
Syndrome = c(KS="Red", BWS="Purple", DS="orange", RSTS="forest green", Control = "Grey"))
#myLoad$pd$Slide <- as.numeric(myLoad$pd$Slide)
myLoad$pd$Slide <- as.character(myLoad$pd$Slide)
myNorm <- champ.norm(beta=myLoad$beta,
arraytype=methylationarray,
method=norm,
plotBMIQ = TRUE,
cores = 8)
champ.SVD(beta = myNorm,
PDFplot = TRUE,
pd = myLoad$pd,
RGEffect = FALSE)
myCombat <- champ.runCombat(beta=myNorm,
variablename="Syndrome",
pd=myLoad$pd,
batchname=c("Array"),
logitTrans=TRUE
)
champ.SVD(beta=myCombat,
PDFplot=TRUE,
pd=myLoad$pd,
RGEffect=FALSE
)
#myCombat <- myNorm
myRefBase <- champ.refbase(beta=myCombat,arraytype="EPIC")
head(myRefBase)
myRefBase$CellFraction
cf <- myRefBase$CellFraction
dim(cf)
head(cf)
View(cf)
head(myLoad$pd$Sample_Group)
myLoad$pd$Sample_Group
myLoad$pd$Syndrome
a = cf[myLoad$pd$Syndrome == "DS",]
a
b = cf[myLoad$pd$Syndrome == "Control",]
boxplot(a, at=0:5*3 + 1, xlim=c(0, 18), ylim=range(a, b), xaxt="n",
col=age.pal[1], main="", ylab="Cell type proportion")
library(RColorBrewer)
boxplot(a, at=0:5*3 + 1, xlim=c(0, 18), ylim=range(a, b), xaxt="n",
col=age.pal[1], main="", ylab="Cell type proportion")
age.pal <- brewer.pal(8,"Set1")
boxplot(a, at=0:5*3 + 1, xlim=c(0, 18), ylim=range(a, b), xaxt="n",
col=age.pal[1], main="", ylab="Cell type proportion")
boxplot(b, at=0:5*3 + 2, xaxt="n", add=TRUE, col=age.pal[2])
par(mfrow=c(1,1))
a = cf[myLoad$pd$Syndrome == "DS",]
b = cf[myLoad$pd$Syndrome == "Control",]
boxplot(a, at=0:5*3 + 1, xlim=c(0, 18), ylim=range(a, b), xaxt="n",
col=age.pal[1], main="", ylab="Cell type proportion")
boxplot(b, at=0:5*3 + 2, xaxt="n", add=TRUE, col=age.pal[2])
axis(1, at=0:5*3 + 1.5, labels=colnames(a), tick=TRUE)
legend("topleft", legend=c("NewBorns","OLD"), fill=age.pal)
par(mfrow=c(1,1))
a = cf[myLoad$pd$Syndrome == "DS",]
b = cf[myLoad$pd$Syndrome == "Control",]
boxplot(a, at=0:5*3 + 1, xlim=c(0, 18), ylim=range(a, b), xaxt="n",
col=age.pal[1], main="", ylab="Cell type proportion")
boxplot(b, at=0:5*3 + 2, xaxt="n", add=TRUE, col=age.pal[2])
axis(1, at=0:5*3 + 1.5, labels=colnames(a), tick=TRUE)
legend("topleft", legend=c("DS","Control"), fill=age.pal)
champ.refbase
data(CellTypeMeans450K)
CellTypeMeans450K
help("wilcox.test")
knitr::opts_chunk$set(echo = TRUE)
library(scater)
fname
paste0("Number of cells: ", dim(sce)[2])
paste0("Number of cells: ", dim(sce)[2])
paste0("Number of genes: ", dim(sce)[1])
table(sce$Group)
setwd("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data")
ls
ls
cd ..
ls
source("simulate_data.R")
setwd("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data")
source("simulate_data.R")
source("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R")
setwd("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data")
source("simulate_data.R")
source("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R")
source("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R", encoding = "UTF-8")
# Check if the file exists
file.exists("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R")
# Check file permissions
file.info("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R")
source("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R")
correct_path <- normalizePath("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R")
print(correct_path) # Check the normalized path
# Now try sourcing the normalized path
source(correct_path)
getwd()
source("simulate_data.R")
file_connection <- file("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R", "r")
readLines(file_connection)  # To see if the file can be read
close(file_connection)
source("/home/francescoc/Desktop/Project/tdsc/Benchmarking_Clustering_Methods_scRNAseq/simulate_data/simulate_data.R", encoding = "UTF-8")
source("test.R")
setwd("/home/francescoc/Desktop/Project/tdsc/scData_simulation")
source("simulate_data.R")
# Load necessary library
library(Matrix)
# Set the parameters
set.seed(42)  # For reproducibility
n_cells <- 100  # Number of T cells
n_genes <- 2000  # Number of genes (e.g., from T-cell markers and other genes)
mean_expression <- 10  # Mean expression value per gene
t_cell_marker_genes <- c("CD3D", "CD3E", "CD3G", "CD4", "CD8A", "CD8B")
# Step 1: Create a random gene expression matrix
# Simulate gene expression counts using a Negative Binomial distribution
gene_expression_matrix <- matrix(rnbinom(n_cells * n_genes, size=1, mu=mean_expression),
nrow=n_genes,
ncol=n_cells)
# Step 2: Add cell and gene names
gene_names <- paste0("Gene", 1:n_genes)  # Default gene names
colnames(gene_expression_matrix) <- paste0("Cell_", 1:n_cells)
rownames(gene_expression_matrix) <- gene_names
# Step 3: Simulate higher expression for T cell marker genes
# Let's simulate higher expression of some T cell marker genes
for (marker in t_cell_marker_genes) {
if (marker %in% gene_names) {
gene_expression_matrix[which(gene_names == marker), ] <- rnbinom(n_cells, size=1, mu=50)  # Higher expression
}
}
# Step 4: Add dropout noise (optional)
dropout_rate <- 0.1  # Assume 10% dropout rate
dropout_matrix <- matrix(rbinom(n_cells * n_genes, 1, dropout_rate), nrow=n_genes, ncol=n_cells)
gene_expression_matrix[dropout_matrix == 1] <- 0
# Step 5: Create a sparse matrix to save memory (optional)
sparse_gene_expression_matrix <- Matrix(gene_expression_matrix, sparse = TRUE)
# View the first few rows and columns of the matrix
head(gene_expression_matrix[, 1:5])
dim(gene_expression_matrix)
# Read the data
file_path <- "/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt"  # Replace with your actual file path
data <- read.table(file_path, header = FALSE, sep = "\t", stringsAsFactors = FALSE)
# Assign column names to the data frame
colnames(data) <- c("Gene1", "Gene2", "Weight", "NetworkGroup", "Network")
# Create a list of unique genes
genes <- unique(c(data$Gene1, data$Gene2))
# Initialize an adjacency matrix with zeros
adj_matrix <- matrix(0, nrow = length(genes), ncol = length(genes),
dimnames = list(genes, genes))
# Populate the adjacency matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$Weight[i]
# Assign weight to both gene pairs (symmetrically)
adj_matrix[gene1, gene2] <- weight
adj_matrix[gene2, gene1] <- weight
}
# Convert the adjacency matrix to a data frame for easier viewing
adj_matrix_df <- as.data.frame(adj_matrix)
# Print the adjacency matrix
print(adj_matrix_df)
# Save the adjacency matrix to a CSV file (optional)
write.csv(adj_matrix_df, "adjacency_matrix.csv", row.names = TRUE)
# Read the data
file_path <- "/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt"  # Replace with your actual file path
# Load necessary library
library(dplyr)
data <- read.table(file_path, header = T, sep = "\t", stringsAsFactors = FALSE)
# Assign column names to the data frame
colnames(data) <- c("Gene1", "Gene2", "Weight", "NetworkGroup", "Network")
# Create a list of unique genes
genes <- unique(c(data$Gene1, data$Gene2))
# Initialize an adjacency matrix with zeros
adj_matrix <- matrix(0, nrow = length(genes), ncol = length(genes),
dimnames = list(genes, genes))
# Populate the adjacency matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$Weight[i]
# Assign weight to both gene pairs (symmetrically)
adj_matrix[gene1, gene2] <- weight
adj_matrix[gene2, gene1] <- weight
}
# Convert the adjacency matrix to a data frame for easier viewing
adj_matrix_df <- as.data.frame(adj_matrix)
# Print the adjacency matrix
print(adj_matrix_df)
View
View(adj_matrix_df)
# Save the adjacency matrix to a CSV file (optional)
write.csv(adj_matrix_df, "adjacency_matrix.csv", row.names = TRUE)
# Load necessary library
library(dplyr)
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
# Load necessary library
library(dplyr)
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
# Read the data
file_path <- "genemania-interactions.txt"  # Replace with your actual file path
data <- read.table(file_path, header = T, sep = "\t", stringsAsFactors = FALSE)
# Load necessary library
library(dplyr)
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
getwd()
setwd("/home/francescoc/Desktop/scGRN_simulation/data/genemania-interactions.txt")
# Load required libraries
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
setwd("/home/francescoc/Desktop/scGRN_simulation/Bnet")
count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",")
marker <- read.table("./../data/Tcell.marker.csv", header = T, sep = ",")
count_matrix1 <- as.data.frame(count_matrix[1])
colnames(count_matrix1) <- colnames(adjm)
count_matrix2 <- as.data.frame(count_matrix[2])
colnames(count_matrix2) <- colnames(adjm)
count_matrix3 <- as.data.frame(count_matrix[3])
colnames(count_matrix3) <- colnames(adjm)
count_matrix4 <- as.data.frame(count_matrix[4])
colnames(count_matrix4) <- colnames(adjm)
count_matrix5 <- as.data.frame(count_matrix[5])
colnames(count_matrix5) <- colnames(adjm)
# Run GENIE3 using the count matrix
set.seed(123)
regulatory_network_genie3 <- GENIE3(t(count_matrix1))
# Extract link list (gene regulatory interactions) from GENIE3 results
link_list_genie3 <- getLinkList(regulatory_network_genie3)
# Save the results
write.csv(link_list_genie3, "genie3_network.csv", row.names = FALSE)
#link_list_genie3 <- link_list_genie3 %>% filter(weight >= 0.1)
# List of unique genes
gene_names <- unique(c(link_list_genie3$regulator, link_list_genie3$target))
# Create an empty adjacency matrix
adj_matrix_genie3 <- matrix(0, nrow = length(gene_names), ncol = length(gene_names))
rownames(adj_matrix_genie3) <- colnames(adj_matrix_genie3) <- gene_names
# Fill the adjacency matrix based on the links from GENIE3 with a weight condition
for (i in 1:nrow(link_list_genie3)) {
regulator <- link_list_genie3$regulator[i]
target <- link_list_genie3$target[i]
weight <- link_list_genie3$weight[i]
# Only set 1 if the weight is >= 0.1
if (weight >= 0.1) {
adj_matrix_genie3[regulator, target] <- 1
}
}
# Export the adjacency matrix if needed
write.csv(adj_matrix_genie3, "genie3_adjacency_matrix.csv")
# Create igraph objects for both networks
graph_genie3 <- graph_from_adjacency_matrix(adj_matrix_genie3, mode = "undirected")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "undirected")
# Plot both networks side by side
par(mfrow = c(1, 2))  # Side by side plotting
# Plot GENIE3 Network
plot(graph_genie3, main = "GENIE3 Inferred Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
# Plot Provided Network
plot(graph_provided, main = "Provided Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
par(mfrow = c(1, 1))  # Reset plotting layout
# Get the edges for both networks
edges_genie3 <- igraph::as_data_frame(graph_genie3, what = "edges")
edges_provided <- igraph::as_data_frame(graph_provided, what = "edges")
# Convert edges to sets of pairs (for easy comparison)
edges_genie3_set <- paste(edges_genie3$from, edges_genie3$to, sep = "-")
edges_provided_set <- paste(edges_provided$from, edges_provided$to, sep = "-")
# Calculate the Jaccard similarity between the two sets of edges
common_edges <- intersect(edges_genie3_set, edges_provided_set)
union_edges <- union(edges_genie3_set, edges_provided_set)
jaccard_similarity <- length(common_edges) / length(union_edges)
cat("Jaccard Similarity: ", jaccard_similarity, "\n")
help(graph_from_adjacency_matrix)
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/Bnet")
# Create igraph objects for both networks
graph_genie3 <- graph_from_adjacency_matrix(adj_matrix_genie3, mode = "directed")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "directed")
# Plot both networks side by side
par(mfrow = c(1, 2))  # Side by side plotting
# Create igraph objects for both networks
graph_genie3 <- graph_from_adjacency_matrix(adj_matrix_genie3, mode = "directed")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "directed")
# Plot both networks side by side
par(mfrow = c(1, 2))  # Side by side plotting
# Plot GENIE3 Network
plot(graph_genie3, main = "GENIE3 Inferred Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
# Plot Provided Network
plot(graph_provided, main = "Provided Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
par(mfrow = c(1, 1))  # Reset plotting layout
View(graph_genie3)
link_list_genie3 <- link_list_genie3 %>% filter(weight >= 0.1)
# List of unique genes
gene_names <- unique(c(link_list_genie3$regulator, link_list_genie3$target))
# Create an empty adjacency matrix
adj_matrix_genie3 <- matrix(0, nrow = length(gene_names), ncol = length(gene_names))
rownames(adj_matrix_genie3) <- colnames(adj_matrix_genie3) <- gene_names
# Fill the adjacency matrix based on the links from GENIE3 with a weight condition
for (i in 1:nrow(link_list_genie3)) {
regulator <- link_list_genie3$regulator[i]
target <- link_list_genie3$target[i]
weight <- link_list_genie3$weight[i]
# Only set 1 if the weight is >= 0.1
if (weight >= 0.1) {
adj_matrix_genie3[regulator, target] <- 1
}
}
library(DT)
count_matrix1 %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "non-MLID DVPs anno")
count_matrix1 <- as.data.frame(count_matrix[1])
colnames(count_matrix1) <- colnames(adjm)
rownames(count_matrix1) <- paste("cell", 1:nrow(count_matrix1), sep = "")
count_matrix1 %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "non-MLID DVPs anno")
count_matrices <- list()
for (i in 1:5) {
count_matrix_i <- as.data.frame(count_matrix[[i]])
colnames(count_matrix_i) <- colnames(adjm)
rownames(count_matrix_i) <- paste("cell", 1:nrow(count_matrix_i), sep = "")
count_matrices[[i]] <- count_matrix_i
}
count_matrices[1] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "non-MLID DVPs anno")
count_matrices
count_matrices[[1]]
count_matrices[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "non-MLID DVPs anno")
set.seed(123)
regulatory_network_genie3 <- GENIE3(t(count_matrices[[1]]))
# Extract link list (gene regulatory interactions) from GENIE3 results
link_list_genie3 <- getLinkList(regulatory_network_genie3)
link_list_genie3 %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "Simulated count matrix")
link_list_genie3 %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GENIE3 output")
write.csv(link_list_genie3, "genie3_network.csv", row.names = FALSE)
# List of unique genes
gene_names <- unique(c(link_list_genie3$regulator, link_list_genie3$target))
# Create an empty adjacency matrix
adj_matrix_genie3 <- matrix(0, nrow = length(gene_names), ncol = length(gene_names))
rownames(adj_matrix_genie3) <- colnames(adj_matrix_genie3) <- gene_names
# Fill the adjacency matrix based on the links from GENIE3 with a weight condition
for (i in 1:nrow(link_list_genie3)) {
regulator <- link_list_genie3$regulator[i]
target <- link_list_genie3$target[i]
weight <- link_list_genie3$weight[i]
# Only set 1 if the weight is >= 0.1
if (weight >= 0.1) {
adj_matrix_genie3[regulator, target] <- 1
}
}
adj_matrix_genie3 %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GENIE3 adjacency matrix 0.1")
# Export the adjacency matrix if needed
write.csv(adj_matrix_genie3, "genie3_adjacency_matrix.csv")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "directed")
# Create igraph objects for both networks
graph_genie3 <- graph_from_adjacency_matrix(adj_matrix_genie3, mode = "directed")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "directed")
# Create igraph objects for both networks
graph_genie3 <- graph_from_adjacency_matrix(adj_matrix_genie3, mode = "directed")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "directed")
# Plot both networks side by side
par(mfrow = c(1, 2))  # Side by side plotting
# Plot GENIE3 Network
plot(graph_genie3, main = "GENIE3 Inferred Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
# Plot Provided Network
plot(graph_provided, main = "Provided Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
par(mfrow = c(1, 1))  # Reset plotting layout
# Create igraph objects for both networks
graph_genie3 <- graph_from_adjacency_matrix(adj_matrix_genie3, mode = "directed")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "directed")
# Plot both networks side by side
par(mfrow = c(1, 2))  # Side by side plotting
# Plot GENIE3 Network
plot(graph_genie3, main = "GENIE3 Inferred Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
# Plot Provided Network
plot(graph_provided, main = "Provided Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
par(mfrow = c(1, 1))  # Reset plotting layout
# Create igraph objects for both networks
graph_genie3 <- graph_from_adjacency_matrix(adj_matrix_genie3, mode = "undirected")
graph_provided <- graph_from_adjacency_matrix(as.matrix(adjm), mode = "undirected")
# Plot both networks side by side
par(mfrow = c(1, 2))  # Side by side plotting
# Plot GENIE3 Network
plot(graph_genie3, main = "GENIE3 Inferred Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
# Plot Provided Network
plot(graph_provided, main = "Provided Network", vertex.label.color = "black",
vertex.size = 10, edge.arrow.size = 0.5, vertex.label.cex = 0.7)
par(mfrow = c(1, 1))  # Reset plotting layout
# Install reticulate if not already installed
if (!requireNamespace("reticulate", quietly = TRUE)) {
install.packages("reticulate")
}
# Load reticulate library to interface with Python
library(reticulate)
py_install("arboreto")
#sudo apt-get install python3-venv
py_install("arboreto")
$ sudo apt-get install python3-venv
py_install("pandas")
py_install("numpy")
#sudo apt-get install python3-venv
py_install("arboreto", envname = "r-reticulate")
py_install("pandas", envname = "r-reticulate")
py_install("numpy", envname = "r-reticulate")
