% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/community_path.R
\name{community_path}
\alias{community_path}
\title{Community Detection and Pathway Enrichment Analysis}
\usage{
community_path(
  adj_matrix,
  methods = "louvain",
  pathway_db = "KEGG",
  genes_path = 5,
  plot = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{adj_matrix}{A square adjacency matrix. Row and column names must
correspond to gene symbols.}

\item{methods}{A character vector of one or two community detection
methods supported by \pkg{robin}. If two are given, performance is
compared and the best is selected. Default: \code{"louvain"}.}

\item{pathway_db}{Character string specifying the pathway database to use:
\code{"KEGG"} or \code{"Reactome"}. Default: \code{"KEGG"}.}

\item{genes_path}{Integer. Minimum number of genes per community to run
enrichment analysis. Default: \code{5}.}

\item{plot}{Logical. If \code{TRUE}, generates a plot of detected
communities. Default: \code{TRUE}.}

\item{verbose}{Logical. If \code{TRUE}, shows progress messages.
Default: \code{TRUE}.}
}
\value{
A list with elements:
\itemize{
\item \code{communities}: List with \code{best_method} and a named
vector of community membership per gene.
\item \code{pathways}: List of enrichment results per community
(only for communities meeting size threshold).
\item \code{graph}: The \pkg{igraph} object with community
annotations.
}
}
\description{
Detects gene communities within an adjacency network using one or two
community detection methods, and performs pathway enrichment for each
detected community.
}
\details{
If two methods are provided, the function uses
\code{robinCompare} and selects the method with higher AUC. Pathway
enrichment is done via \pkg{clusterProfiler} (KEGG) or via
\pkg{ReactomePA} (Reactome). Communities smaller than
\code{genes_path} are excluded.
}
\examples{
data(count_matrices)
data(adj_truth)
networks <- infer_networks(
    count_matrices_list = count_matrices,
    method = "GENIE3",
    nCores = 15
)
head(networks[[1]])

wadj_list <- generate_adjacency(networks)
swadj_list <- symmetrize(wadj_list, weight_function = "mean")

binary_listj <- cutoff_adjacency(
    count_matrices = count_matrices,
    weighted_adjm_list = swadj_list,
    n = 2,
    method = "GENIE3",
    quantile_threshold = 0.99,
    nCores = 15,
    debug = TRUE
)
head(binary_listj[[1]])

consensus <- create_consensus(binary_listj, method = "vote")
comm_cons <- community_path(consensus)

}
