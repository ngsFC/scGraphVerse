% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cutoff_adjacency.R
\name{cutoff_adjacency}
\alias{cutoff_adjacency}
\title{Threshold Adjacency Matrices Based on Shuffled Network Quantiles}
\usage{
cutoff_adjacency(
  count_matrices,
  weighted_adjm_list,
  n,
  method = "GENIE3",
  quantile_threshold = 0.99,
  weight_function = "mean",
  nCores = 1,
  grnboost_modules = NULL,
  debug = FALSE
)
}
\arguments{
\item{count_matrices}{A list of expression matrices (genes × cells) or
\linkS4class{Seurat} or \linkS4class{SingleCellExperiment}
objects.}

\item{weighted_adjm_list}{A list of weighted adjacency matrices (one per
expression matrix) to threshold.}

\item{n}{Integer. Number of shuffled replicates generated per original
expression matrix.}

\item{method}{Character string. One of \code{"GENIE3"}, \code{"GRNBoost2"},
or \code{"JRF"}.}

\item{quantile_threshold}{Numeric. The quantile used to define the cutoff.
Default is \code{0.99}.}

\item{weight_function}{Character string or function used to symmetrize
adjacency matrices (\code{"mean"}, \code{"max"}, etc.).}

\item{nCores}{Integer. Number of CPU cores to use for
parallelization. Default is the number of workers in the current
\pkg{BiocParallel} backend.}

\item{grnboost_modules}{Python modules needed for \code{GRNBoost2} if
using reticulate.}

\item{debug}{Logical. If \code{TRUE}, prints detailed progress messages.
Default is \code{FALSE}.}
}
\value{
A list of binary (thresholded) adjacency matrices, each
corresponding to an input weighted matrix.
}
\description{
Applies a cutoff to weighted adjacency matrices using a percentile
estimated from shuffled versions of the original expression matrices.
Supports inference methods \code{"GENIE3"}, \code{"GRNBoost2"},
and \code{"JRF"}.
}
\details{
For each input expression matrix, \code{n} shuffled versions are
generated by randomly permuting each gene’s expression across cells.
Network inference is performed on the shuffled matrices, and a cutoff
is determined as the specified quantile (\code{quantile_threshold}) of
the resulting edge weights. The original weighted adjacency matrices
are then thresholded using these estimated cutoffs.

Parallelization is handled via \pkg{BiocParallel}.

The methods are based on:
\itemize{
\item \strong{GENIE3}: Random Forest-based inference (Huynh-Thu et
al., 2010).
\item \strong{GRNBoost2}: Gradient boosting trees using arboreto
(Moerman et al., 2019).
\item \strong{JRF}: Joint Random Forests across multiple conditions
(Petralia et al., 2015).
}
}
\examples{
set.seed(123)

# Simulate two small expression matrices
mat1 <- matrix(rpois(100, lambda = 5), nrow = 10, ncol = 10)
mat2 <- matrix(rpois(100, lambda = 5), nrow = 10, ncol = 10)
rownames(mat1) <- paste0("Gene", 1:10)
rownames(mat2) <- paste0("Gene", 1:10)

# Infer networks using GENIE3
network_list <- infer_networks(
    count_matrices_list = list(mat1, mat2),
    method = "GENIE3",
    nCores = 2
)

# Convert inferred networks into adjacency matrices
list_wadj <- generate_adjacency(network_list)
list_swadj <- symmetrize(
    list_wadj,
    weight_function = "mean"
)

# Apply cutoff based on shuffled quantiles
binary_adjm_list <- cutoff_adjacency(
    count_matrices     = list(mat1, mat2),
    weighted_adjm_list = list_swadj,
    n                  = 2,
    method             = "GENIE3",
    quantile_threshold = 0.95,
    nCores             = 2,
    debug              = TRUE
)

# Inspect one thresholded adjacency matrix
binary_adjm_list[[1]]
}
