---
title: "scGRN testing"
author: "Francesco Cecere"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    theme: cerulean
    df_print: paged
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/R")
```

```{r global options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable", timing = TRUE)
```

```{r libraries, timing = TRUE}
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
library(rbenchmark)
library(reshape2)
library(gridExtra)
library(tictoc)
```

```{r}
source("dropo.R")
source("earlyj.R")
```


# Simulate Data

```{r, timing=T}
#count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()

ncell <- 500
nodes <- nrow(adjm)

tictoc::tic()
set.seed(1130)
count_matrices <- lapply(1:5, function(i) {
  set.seed(1130 + i)
  count_matrix_i <- simdata(n = ncell, p = nodes, B = adjm, family = "ZINB", 
                            mu = 5, mu_noise = 1, theta = 1, pi = 0.2)
  
  count_matrix_df <- as.data.frame(count_matrix_i)
  colnames(count_matrix_df) <- colnames(adjm)
  rownames(count_matrix_df) <- paste("cell", 1:nrow(count_matrix_df), sep = "")
  
  return(count_matrix_df)
})

count_matrices[[1]] %>%
    datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "Simulated count matrix")

saveRDS(count_matrices, "./../analysis/count_matrices.RDS")
tictoc::toc()
```


```{r}
set.seed(5463)

for (i in 1:length(count_matrices)) {
  set.seed(1130 + i)
  count_matrices[[i]] <- dropo(count_matrices[[i]], dropout_rate = 0.10)
}

saveRDS(count_matrices, "./../analysis/count_matrices_drop010.RDS")

count_matrice <- list(earlyj(count_matrices))
saveRDS(count_matrice, "./../analysis/count_matrices_drop010_combined.RDS")

count_matrices[[1]] %>%
    datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "Simulated count matrix")

```


# GENIE3

This document provides a detailed explanation of the mathematical formulations and algorithms used in the research paper *"Inferring Regulatory Networks from Expression Data Using Tree-Based Methods"*. The algorithm discussed in this paper is GENIE3, which uses tree-based ensemble methods for the inference of genetic regulatory networks (GRNs) from expression data.

## Problem Definition

Let \( p \) be the number of genes, and \( x^k \) be a vector representing the expression values of all \( p \) genes in the \( k \)-th experiment. The goal is to predict the regulatory links between these genes.

- **Formula 1**: The expression of a target gene \( j \) in a given condition can be expressed as a function of other genes plus random noise:

\[
x_j^k = f_j(x^{-j}_k) + e_k
\]

where \( x^{-j}_k \) is the expression values of all genes except gene \( j \), \( f_j \) is an unknown function, and \( e_k \) is a random noise with zero mean.

## Feature Selection Problem

Identifying regulatory links for gene \( j \) involves selecting features that predict \( x_j \). This can be framed as a feature selection problem in regression.

- **Formula 2**: Variable importance measure in tree-based methods is computed using the total reduction of variance:

\[
I(N) = \#S \, Var(S) - \#S_t \, Var(S_t) - \#S_f \, Var(S_f)
\]

where \( S \), \( S_t \), and \( S_f \) denote the sets of samples in the current node, true branch, and false branch, respectively.

## Performance Metrics

The performance of the algorithm is evaluated using metrics such as **AUPR** (Area Under Precision-Recall Curve) and **AUROC** (Area Under Receiver Operating Characteristic Curve).

- **Precision**: The proportion of true positives among the predicted positives.
- **Recall**: The proportion of true positives that are correctly identified.

## Further Improvements

Several aspects of the algorithm can be fine-tuned, such as the choice of the parameter \( K \) in the Random Forest or Extra-Trees method.

## References

- Huynh-Thu V, Irrthum A, Wehenkel L, Geurts P (2010). “Inferring regulatory networks from expression data using tree-based methods.” **PLoS ONE**, 5(9), e12776.

- Aibar S, Bravo Gonzalez-Blas C, Moerman T, Huynh-Thu V, Imrichova H, Hulselmans G, Rambow F, Marine J, Geurts P, Aerts J, van den Oord J, Kalender Atak Z, Wouters J, Aerts S (2017). “SCENIC: Single-Cell Regulatory Network Inference And Clustering.” **Nature Methods**, 14, 1083-1086.

## Early join

```{r}
set.seed(123)

link_list_genie3_list <- list()
tictoc::tic()
for (i in seq_along(count_matrice)) {
  regulatory_network_genie3 <- GENIE3(t(count_matrice[[i]]))
  link_list_genie3 <- getLinkList(regulatory_network_genie3)
  link_list_genie3_list[[paste0("Matrix_", i)]] <- link_list_genie3
  }

saveRDS(link_list_genie3_list, "./../analysis/early_genie3_network_list.RDS")
#link_list_genie3_list <- readRDS("./../analysis/genie3_network_list.RDS")

link_list_genie3_list[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "GENIE3 output")
tictoc::toc()
```


## Late Join


```{r}
set.seed(123)

link_list_genie3_list <- list()
tictoc::tic()
for (i in seq_along(count_matrices)) {
  regulatory_network_genie3 <- GENIE3(t(count_matrices[[i]]))
  link_list_genie3 <- getLinkList(regulatory_network_genie3)
  link_list_genie3_list[[paste0("Matrix_", i)]] <- link_list_genie3
  }

saveRDS(link_list_genie3_list, "./../analysis/genie3_network_list.RDS")
#link_list_genie3_list <- readRDS("./../analysis/genie3_network_list.RDS")
tictoc::toc()
link_list_genie3_list[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "GENIE3 output")
```


# GRNBoost2


```{r}
use_python("/usr/bin/python3", required = TRUE)
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")
```


## Early join

```{r}
count_matrice <- list(earlyj(count_matrices))

set.seed(123)

all_grn_links <- list()
tictoc::tic()
for (i in seq_along(count_matrice)) {
  count_matrix_df <- as.data.frame(count_matrice[[i]])
  genes <- colnames(count_matrix_df)
  df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = genes, index = rownames(count_matrix_df))
  grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
  all_grn_links[[i]] <- grn_links
  }

saveRDS(all_grn_links, "./../analysis/early_grnboost2_network_list.RDS")

all_grn_links[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "GRNBoost2 Early Join")
tictoc::toc()
```


## Late Join

```{r}
all_grn_links <- list()

tictoc::tic()
for (i in seq_along(count_matrices)) {
  count_matrix_df <- as.data.frame(count_matrices[[i]])
  genes <- colnames(count_matrix_df)
  df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = genes, index = rownames(count_matrix_df))
  grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
  all_grn_links[[i]] <- grn_links
  }

saveRDS(all_grn_links, "./../analysis/grnboost2_network_list.RDS")

all_grn_links[[1]] %>%
  datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "GRNBoost2 Late Join")
tictoc::toc()

```


## GRNBoost2 cutoff


```{r}
# Step 1: Create a function to shuffle inside each row of a matrix, with a different seed
shuffle_rows <- function(matrix, seed_vector) {
  # Shuffle each row of the matrix based on the seed_vector
  shuffled_matrix <- matrix
  for (i in 1:nrow(matrix)) {
    set.seed(seed_vector[i])
    shuffled_matrix[i, ] <- sample(matrix[i, ])
  }
  return(shuffled_matrix)
}

# Step 2: Shuffle it and store everything into a list of n shuffles
create_shuffled_matrices <- function(original_matrix, n) {
  # Create n shuffled matrices
  shuffled_matrices <- list()
  for (i in 1:n) {
    # Generate a unique seed vector for each shuffle
    seed_vector <- sample(1:10000, nrow(original_matrix))
    shuffled_matrix <- shuffle_rows(original_matrix, seed_vector)
    shuffled_matrices[[i]] <- shuffled_matrix
  }
  return(shuffled_matrices)
}

# Number of shuffles to create
n_shuffles <- 100

# Generate n shuffled matrices
shuffled_matrices_list <- create_shuffled_matrices(count_matrice[[1]], n_shuffles)

# Step 3: Use a loop to compute GRNBoost2 results for each shuffled matrix
all_grn_links <- list()

tictoc::tic()
for (i in 1:length(shuffled_matrices_list)) {
  count_matrix_df <- as.data.frame(shuffled_matrices_list[[i]])
  genes <- colnames(count_matrix_df)
  
  df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = genes, index = rownames(count_matrix_df))
  grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
  all_grn_links[[i]] <- grn_links
}
tictoc::toc()

# Step 4: Run the simmetric.R function on each GRNBoost2 result
source("simmetric.R")
all_grn_links <- simmetric(all_grn_links, weight_function = "mean")

# Step 5: Calculate the 5th percentile for the weight column in each GRNBoost2 result
percentile_values <- sapply(all_grn_links, function(grn_result) {
  ordered_weights <- sort(grn_result$weight)
  quantile(ordered_weights, 0.05)
})

# Print or store the results
print(percentile_values)

percentile_values <- sapply(all_grn_links, function(grn_result) {
  ordered_weights <- sort(grn_result$weight)
  threshold <- quantile(ordered_weights, 0.95)
  return(threshold)
})

mean_value <- mean(percentile_values)

hist(percentile_values, main="Histogram of percentile_values", xlab="percentile_values", col="grey")
abline(v = mean_value, col = "red", lwd = 2, lty = 2)
legend("topright", legend = paste("Mean:", round(mean_value, 3)), col = "red", lwd = 2, lty = 2)
```

