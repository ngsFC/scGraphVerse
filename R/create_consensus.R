#' Generate Consensus Adjacency Matrix from a List of Adjacency Matrices
#'
#' This function generates a consensus adjacency matrix from a list of adjacency matrices. It supports 
#' three methods for generating the consensus: "vote", "union", and "INet".
#' - **"vote"**: The consensus matrix is generated by selecting edges that are present in at least 75% of the 
#'   matrices in the input list.
#' - **"union"**: The consensus matrix is generated by taking the union of all matrices, where any edge present 
#'   in any matrix is included in the consensus.
#' - **"INet"**: The consensus matrix is generated using weighted adjacency matrices, where the weights are 
#'   normalized and combined to form the consensus network.
#'
#' @param adj_matrix_list A list of binary adjacency matrices to be used to generate the consensus matrix.
#'        All matrices should have the same dimensions.
#' @param method A character string specifying the method for generating the consensus. Options are:
#'        "vote" (default), "union", and "INet".
#' @param weighted_list A list of weighted adjacency matrices, required only when `method = "INet"`. It is 
#'        used to apply weighted information to the consensus generation.
#' @param theta A numeric value specifying the threshold for consensus when using the "INet" method. It is 
#'        passed to the `consensusNet` function. The default value is 0.04.
#' @param threshold A numeric value between 0 and 1. For the "vote" method, this threshold defines the minimum 
#'        percentage of matrices in which an edge must be present to be included in the consensus.
#'        For the "union" method, any edge with a value >= 1 in any matrix will be included.
#' @param ncores The number of CPU cores to use when generating the consensus matrix using the "INet" method. 
#'        The default is 1 (single-core).
#'
#' @return A square matrix representing the consensus adjacency matrix.
#'
#' @details
#' The `create_consensus` function generates a consensus adjacency matrix from a list of binary or weighted 
#' adjacency matrices. It provides flexibility for different methods:
#' - The "vote" method considers an edge present if it appears in at least 75% of the input matrices.
#' - The "union" method includes any edge present in any matrix in the consensus matrix.
#' - The "INet" method combines weighted matrices by normalizing the values and creating a consensus network 
#'   using the `consensusNet` function.
#'
#' @importFrom igraph as_adjacency_matrix
#' @importFrom INetTool consensusNet
#' 
#' @export
create_consensus <- function(adj_matrix_list, method = "vote", weighted_list = NULL, theta = 0.04, threshold = 0.5, ncores = 1) {
  
  # Sum all adjacency matrices to get consensus values (default for 'vote' and 'union')
  consensus_matrix <- Reduce("+", adj_matrix_list)
  
  if (method == "vote") {
    # Define threshold (present in at least 75% of the adjacency matrices)
    threshold_value <- round(length(adj_matrix_list) * 0.75)
    
    # Apply threshold: 1 if >= threshold, 0 if < threshold
    consensus_matrix[consensus_matrix < threshold_value] <- 0
    consensus_matrix[consensus_matrix >= threshold_value] <- 1
  } else if (method == "union") {
    # Union method: any position with a value >= 1 in any matrix is set to 1
    consensus_matrix[consensus_matrix >= 1] <- 1
  } else if (method == "INet") {
    # Ensure weighted list is provided
    if (is.null(weighted_list)) {
      stop("For method 'INet', a weighted_list must be provided.")
    }
    
    # Element-wise replacement of 1s in binary matrices with corresponding weights
    list_weighted <- mapply(function(binary_mat, weighted_mat) {
      if (!is.matrix(binary_mat) || !is.matrix(weighted_mat)) {
        stop("Both binary and weighted elements must be matrices.")
      }
      if (!all(dim(binary_mat) == dim(weighted_mat))) {
        stop("Dimension mismatch between binary adjacency matrix and weighted matrix.")
      }
      # Replace 1s in binary_mat with weights from weighted_mat
      newmat <- binary_mat * weighted_mat
      return(newmat)
    }, adj_matrix_list, weighted_list, SIMPLIFY = FALSE)
    
    # Normalize the weighted matrices
    list_genie3_norm <- lapply(list_weighted, function(mat) mat / max(mat, na.rm = TRUE))
    
    # Generate consensus network using INet
    Con <- consensusNet(list_genie3_norm, theta = theta, ncores = ncores, threshold = threshold)
    
    # Convert the consensus network graph to an adjacency matrix
    consensus_matrix <- as.matrix(as_adjacency_matrix(Con$graphConsensus))
  } else {
    stop("Invalid method. Choose 'vote', 'union', or 'INet'.")
  }
  
  return(consensus_matrix)
}

