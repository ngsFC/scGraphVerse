---
title: "scGRN testing"
author: "Francesco Cecere"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    theme: cerulean
    df_print: paged
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/R")
```

```{r global options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable", timing = TRUE)
```

```{r libraries, timing = TRUE}
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
library(rbenchmark)
library(reshape2)
library(gridExtra)
```

```{r}
source("dropo.R")
source("generate_adjacency.R")
source("simmetric.R")
source("pscores.R")
```


# Simulate Data

```{r, timing=T}
#count_matrix <- readRDS("./../data/simatx.RDS")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()

ncell <- 500
nodes <- nrow(adjm)

set.seed(1130)
count_matrices <- lapply(1:5, function(i) {
  set.seed(1130 + i)
  count_matrix_i <- simdata(n = ncell, p = nodes, B = adjm, family = "ZINB", 
                            mu = 5, mu_noise = 1, theta = 1, pi = 0.2)
  
  count_matrix_df <- as.data.frame(count_matrix_i)
  colnames(count_matrix_df) <- colnames(adjm)
  rownames(count_matrix_df) <- paste("cell", 1:nrow(count_matrix_df), sep = "")
  
  return(count_matrix_df)
})

count_matrices[[1]] %>%
    datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "Simulated count matrix")

saveRDS(count_matrices, "./../analysis/count_matrices.RDS")
```


```{r}
set.seed(5463)

for (i in 1:length(count_matrices)) {
  set.seed(1130 + i)
  count_matrices[[i]] <- dropo(count_matrices[[i]], dropout_rate = 0.10)
}

saveRDS(count_matrices, "./../analysis/count_matrices_drop010.RDS")

count_matrices[[1]] %>%
    datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "Simulated count matrix")

```


# GENIE3

This document provides a detailed explanation of the mathematical formulations and algorithms used in the research paper *"Inferring Regulatory Networks from Expression Data Using Tree-Based Methods"*. The algorithm discussed in this paper is GENIE3, which uses tree-based ensemble methods for the inference of genetic regulatory networks (GRNs) from expression data.

## Problem Definition

Let \( p \) be the number of genes, and \( x^k \) be a vector representing the expression values of all \( p \) genes in the \( k \)-th experiment. The goal is to predict the regulatory links between these genes.

- **Formula 1**: The expression of a target gene \( j \) in a given condition can be expressed as a function of other genes plus random noise:

\[
x_j^k = f_j(x^{-j}_k) + e_k
\]

where \( x^{-j}_k \) is the expression values of all genes except gene \( j \), \( f_j \) is an unknown function, and \( e_k \) is a random noise with zero mean.

## Feature Selection Problem

Identifying regulatory links for gene \( j \) involves selecting features that predict \( x_j \). This can be framed as a feature selection problem in regression.

- **Formula 2**: Variable importance measure in tree-based methods is computed using the total reduction of variance:

\[
I(N) = \#S \, Var(S) - \#S_t \, Var(S_t) - \#S_f \, Var(S_f)
\]

where \( S \), \( S_t \), and \( S_f \) denote the sets of samples in the current node, true branch, and false branch, respectively.

## Performance Metrics

The performance of the algorithm is evaluated using metrics such as **AUPR** (Area Under Precision-Recall Curve) and **AUROC** (Area Under Receiver Operating Characteristic Curve).

- **Precision**: The proportion of true positives among the predicted positives.
- **Recall**: The proportion of true positives that are correctly identified.

## Further Improvements

Several aspects of the algorithm can be fine-tuned, such as the choice of the parameter \( K \) in the Random Forest or Extra-Trees method.

## References

- Huynh-Thu V, Irrthum A, Wehenkel L, Geurts P (2010). “Inferring regulatory networks from expression data using tree-based methods.” **PLoS ONE**, 5(9), e12776.

- Aibar S, Bravo Gonzalez-Blas C, Moerman T, Huynh-Thu V, Imrichova H, Hulselmans G, Rambow F, Marine J, Geurts P, Aerts J, van den Oord J, Kalender Atak Z, Wouters J, Aerts S (2017). “SCENIC: Single-Cell Regulatory Network Inference And Clustering.” **Nature Methods**, 14, 1083-1086.


## Late Join


```{r}
set.seed(123)

link_list_genie3_list <- list()

for (i in seq_along(count_matrices)) {
  regulatory_network_genie3 <- GENIE3(t(count_matrices[[i]]))
  link_list_genie3 <- getLinkList(regulatory_network_genie3)
  link_list_genie3_list[[paste0("Matrix_", i)]] <- link_list_genie3
  }

saveRDS(link_list_genie3_list, "./../analysis/genie3_network_list.RDS")
#link_list_genie3_list <- readRDS("./../analysis/genie3_network_list.RDS")

link_list_genie3_list[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "GENIE3 output")
```


```{r}
link_list_genie3_list <- simmetric(link_list_genie3_list, weight_function = "min")
link_list_genie3_list[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "GENIE3 simmetric output")
```


```{r}
adj_matrix_list <- generate_adjacency(link_list_genie3_list, weight_quantile = 0.70, output_rds_file = "./../analysis/genie3_adjacency_matrices.RDS")

adj_matrix_list[[1]] %>%
    datatable(extensions = 'Buttons',
              options = list(
                dom = 'Bfrtip',
                buttons = c('csv', 'excel'),
                scrollX = TRUE,
                pageLength = 10), 
              caption = "GENIE3 adjacency")

```



```{r}
scores <- pscores(adjm, adj_matrix_list)

print(scores$Jaccard_Heatmap)
print(scores$Metrics_Barplot)
```



```{r}
plot_non_isolated_genes <- function(adj_matrix_list) {
  par(mfrow = c(2, 3))

  for (i in seq_along(adj_matrix_list)) {
    graph <- graph_from_adjacency_matrix(adj_matrix_list[[i]], mode = "undirected", diag = FALSE)
    non_isolated_vertices <- V(graph)[degree(graph) > 1]
    subgraph <- induced_subgraph(graph, non_isolated_vertices)
    
    plot(subgraph, 
         main = paste("Graph for Matrix", names(adj_matrix_list)[i]), 
         vertex.label.color = "black",
         vertex.size = 1, 
         edge.width = 2, 
         vertex.label.cex = 0.8,
         layout = layout_with_fr)
  }

  # Reset plotting area to default
  par(mfrow = c(1, 1))
}

# Assuming 'adj_matrix_list' contains your adjacency matrices, call the function to plot them
plot_non_isolated_genes(adj_matrix_list)

```



```{r}
create_consensus_matrix <- function(adj_matrix_list) {
  consensus_matrix <- Reduce("+", adj_matrix_list)
  threshold <- length(adj_matrix_list)-2  # All matrices should have this edge
  
  consensus_matrix_binary <- consensus_matrix >= threshold
  
  diag(consensus_matrix_binary) <- 1
  
  return(consensus_matrix_binary)
}

plot_non_isolated_consensus <- function(consensus_matrix) {
  graph <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
  non_isolated_vertices <- V(graph)[degree(graph) > 0]
  subgraph <- induced_subgraph(graph, non_isolated_vertices)
  
  plot(subgraph, 
       main = "", 
       vertex.label.color = "black",
       vertex.size = 1, 
       edge.width = 2, 
       vertex.label.cex = 0.8,
       layout = layout_with_fr)
}

calculate_jaccard_index_adj_matrices <- function(matrix1, matrix2) {
  # Convert matrices to binary (1 if there's an edge, 0 otherwise)
  matrix1_binary <- (matrix1 > 0)
  matrix2_binary <- (matrix2 > 0)
  
  intersection_size <- sum(matrix1_binary & matrix2_binary)  # Element-wise AND
  union_size <- sum(matrix1_binary | matrix2_binary)  # Element-wise OR
  
  jaccard_index <- intersection_size / union_size
  return(jaccard_index)
}

original_consensus_matrix <- create_consensus_matrix(adj_matrix_list)
jaccard_index_entire_matrix <- calculate_jaccard_index_adj_matrices(original_consensus_matrix, adjm)
cat("Jaccard Index :", round(jaccard_index_entire_matrix, 3), "\n")

par(mfrow = c(1, 2)) 
plot_non_isolated_consensus(original_consensus_matrix)
plot_non_isolated_consensus(adjm)
par(mfrow = c(1, 1))

```

```{r}
plot_original_with_highlight <- function(original_matrix, consensus_matrix) {
  graph_original <- graph_from_adjacency_matrix(original_matrix, mode = "undirected", diag = FALSE)
  graph_consensus <- graph_from_adjacency_matrix(consensus_matrix, mode = "undirected", diag = FALSE)
  
  original_edges <- as_edgelist(graph_original)
  consensus_edges <- as_edgelist(graph_consensus)
  
  original_edges_set <- apply(original_edges, 1, function(x) paste(sort(x), collapse = "-"))
  consensus_edges_set <- apply(consensus_edges, 1, function(x) paste(sort(x), collapse = "-"))

  edge_colors <- ifelse(original_edges_set %in% consensus_edges_set, "red", "blue")
  
  plot(graph_original, 
       edge.color = edge_colors, 
       main = "Original Graph with Consensus Highlight",
       vertex.label.color = "black",
       vertex.size = 1, 
       edge.width = 2, 
       vertex.label.cex = 0.8,
       layout = layout_with_fr)
}

plot_original_with_highlight(adjm, original_consensus_matrix)

```


# GRNBoost2


```{r}
use_python("/usr/bin/python3", required = TRUE)
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")

all_grn_links <- list()

for (i in seq_along(count_matrices)) {
  
  count_matrix_df <- as.data.frame(count_matrices[[i]])
  genes <- colnames(count_matrix_df)
  df_pandas <- pandas$DataFrame(data = count_matrix_df, columns = genes, index = rownames(count_matrix_df))
  grn_links <- arboreto$grnboost2(df_pandas, gene_names = genes)
  all_grn_links[[i]] <- grn_links
}

all_grn_links[[1]] %>%
  datatable(extensions = 'Buttons',
            options = list(
              dom = 'Bfrtip',
              buttons = c('csv', 'excel'),
              scrollX = TRUE,
              pageLength = 10), 
            caption = "GRNBoost2 links")

```
