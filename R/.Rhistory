# Assign the weight to both [gene1, gene2] and [gene2, gene1] to ensure symmetry
adj_matrix[row_index, col_index] <- weight
adj_matrix[col_index, row_index] <- weight
}
return(adj_matrix)
}
#weightMat_1 <- simmetric(list(weightMat_1), weight_function = "mean")
generate_adjacency_matrix(weightMat_link)
generate_adjacency_matrices <- function(df_list) {
# Initialize a list to store the adjacency matrices
adj_matrix_list <- list()
# Loop over each data frame in the input list
for (k in seq_along(df_list)) {
data <- df_list[[k]]
# Extract unique genes to determine matrix dimensions
unique_genes <- sort(unique(c(data$Gene1, data$Gene2)))
p <- length(unique_genes)
# Initialize an empty matrix with zeroes
adj_matrix <- matrix(0, nrow = p, ncol = p)
rownames(adj_matrix) <- colnames(adj_matrix) <- unique_genes
# Fill the matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$weight[i]
# Find the row and column indices for each gene
row_index <- which(rownames(adj_matrix) == gene1)
col_index <- which(colnames(adj_matrix) == gene2)
# Assign the weight to both [gene1, gene2] and [gene2, gene1] to ensure symmetry
adj_matrix[row_index, col_index] <- weight
adj_matrix[col_index, row_index] <- weight
}
# Add the matrix to the list
adj_matrix_list[[k]] <- adj_matrix
}
return(adj_matrix_list)
}
#weightMat_1 <- simmetric(list(weightMat_1), weight_function = "mean")
generate_adjacency_matrices(list(weightMat_link))
# Assign the weight to both [gene1, gene2] and [gene2, gene1] to ensure symmetry
adj_matrix[row_index, col_index] <- weight
generate_adjacency_matrices <- function(df_list) {
# Initialize a list to store the adjacency matrices
adj_matrix_list <- list()
# Loop over each data frame in the input list
for (k in seq_along(df_list)) {
data <- df_list[[k]]
# Extract unique genes to determine matrix dimensions
unique_genes <- sort(unique(c(data$Gene1, data$Gene2)))
p <- length(unique_genes)
# Initialize an empty matrix with zeroes
adj_matrix <- matrix(0, nrow = p, ncol = p)
rownames(adj_matrix) <- colnames(adj_matrix) <- unique_genes
# Fill the matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$weight[i]
# Find the row and column indices for each gene
row_index <- which(rownames(adj_matrix) == gene1)
col_index <- which(colnames(adj_matrix) == gene2)
# Assign the weight to both [gene1, gene2] and [gene2, gene1] to ensure symmetry
adj_matrix[row_index, col_index] <- weight
#adj_matrix[col_index, row_index] <- weight
}
# Add the matrix to the list
adj_matrix_list[[k]] <- adj_matrix
}
return(adj_matrix_list)
}
#weightMat_1 <- simmetric(list(weightMat_1), weight_function = "mean")
generate_adjacency_matrices(list(weightMat_link))
colnames(weightMat_link) <- c("Gene1", "Gene2", "weight")
weightMat_1 <- simmetric(list(weightMat_1), weight_function = "mean")
# Set seed for reproducibility
set.seed(123)
# Step 2: Run GENIE3 with nCores=1
weightMat_1 <- GENIE3(exprMatr, nCores=1, verbose=TRUE)
weightMat_link <- getLinkList(weightMat_1)
colnames(weightMat_link) <- c("Gene1", "Gene2", "weight")
weightMat_1 <- simmetric(list(weightMat_1), weight_function = "mean")
# Set seed for reproducibility
set.seed(123)
# Step 2: Run GENIE3 with nCores=1
weightMat_1 <- GENIE3(exprMatr, nCores=1, verbose=TRUE)
weightMat_link <- getLinkList(weightMat_1)
check1 <- generate_adjacency_matrices(list(weightMat_link))
colnames(weightMat_link) <- c("Gene1", "Gene2", "weight")
simweightMat_1 <- simmetric(list(weightMat_link), weight_function = "mean")
check <- generate_adjacency_matrices(list(simweightMat_1))
simweightMat_1
check <- generate_adjacency_matrices(simweightMat_1)
View(check)
View(check[[1]])
View(check1)
View(check1[[1]])
check1
# Set seed for reproducibility
set.seed(123)
# Step 2: Run GENIE3 with nCores=1
weightMat_1 <- GENIE3(exprMatr, nCores=1, verbose=TRUE)
weightMat_link <- getLinkList(weightMat_1)
check1 <- generate_adjacency_matrices(list(weightMat_link))
check1
head(weightMat_link)
class(simweightMat_1)
# Set seed for reproducibility
set.seed(123)
# Step 2: Run GENIE3 with nCores=1
weightMat_1 <- GENIE3(exprMatr, nCores=1, verbose=TRUE)
weightMat_link <- getLinkList(weightMat_1)
colnames(weightMat_link) <- c("Gene1", "Gene2", "weight")
check1 <- generate_adjacency_matrices(list(weightMat_link))
simweightMat_1 <- simmetric(list(weightMat_link), weight_function = "mean")
check <- generate_adjacency_matrices(simweightMat_1)
View(check1)
View(check1[[1]])
View(check[[1]])
View(weightMat_1)
0.037559683
(0.037559683+0.02276299)/2
mean(c(0.037559683,0.02276299))
generate_adjacency_matricesSIMM <- function(df_list) {
# Initialize a list to store the adjacency matrices
adj_matrix_list <- list()
# Loop over each data frame in the input list
for (k in seq_along(df_list)) {
data <- df_list[[k]]
# Extract unique genes to determine matrix dimensions
unique_genes <- sort(unique(c(data$Gene1, data$Gene2)))
p <- length(unique_genes)
# Initialize an empty matrix with zeroes
adj_matrix <- matrix(0, nrow = p, ncol = p)
rownames(adj_matrix) <- colnames(adj_matrix) <- unique_genes
# Fill the matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$weight[i]
# Find the row and column indices for each gene
row_index <- which(rownames(adj_matrix) == gene1)
col_index <- which(colnames(adj_matrix) == gene2)
# Assign the weight to both [gene1, gene2] and [gene2, gene1] to ensure symmetry
adj_matrix[row_index, col_index] <- weight
adj_matrix[col_index, row_index] <- weight
}
# Add the matrix to the list
adj_matrix_list[[k]] <- adj_matrix
}
return(adj_matrix_list)
}
generate_adjacency_matrices <- function(df_list) {
# Initialize a list to store the adjacency matrices
adj_matrix_list <- list()
# Loop over each data frame in the input list
for (k in seq_along(df_list)) {
data <- df_list[[k]]
# Extract unique genes to determine matrix dimensions
unique_genes <- sort(unique(c(data$Gene1, data$Gene2)))
p <- length(unique_genes)
# Initialize an empty matrix with zeroes
adj_matrix <- matrix(0, nrow = p, ncol = p)
rownames(adj_matrix) <- colnames(adj_matrix) <- unique_genes
# Fill the matrix with weights
for (i in 1:nrow(data)) {
gene1 <- data$Gene1[i]
gene2 <- data$Gene2[i]
weight <- data$weight[i]
# Find the row and column indices for each gene
row_index <- which(rownames(adj_matrix) == gene1)
col_index <- which(colnames(adj_matrix) == gene2)
# Assign the weight to both [gene1, gene2] and [gene2, gene1] to ensure symmetry
adj_matrix[row_index, col_index] <- weight
#adj_matrix[col_index, row_index] <- weight
}
# Add the matrix to the list
adj_matrix_list[[k]] <- adj_matrix
}
return(adj_matrix_list)
}
# Set seed for reproducibility
set.seed(123)
# Step 2: Run GENIE3 with nCores=1
weightMat_1 <- GENIE3(exprMatr, nCores=1, verbose=TRUE)
weightMat_link <- getLinkList(weightMat_1)
colnames(weightMat_link) <- c("Gene1", "Gene2", "weight")
check1 <- generate_adjacency_matrices(list(weightMat_link))
simweightMat_1 <- simmetric(list(weightMat_link), weight_function = "mean")
check <- generate_adjacency_matricesSIMM(simweightMat_1)
check[[1]]
View(check1[[1]])
View(check[[1]])
View(weightMat_1)
compare_matrices <- function(matrix1, matrix2) {
# Check if dimensions are the same
if (!all(dim(matrix1) == dim(matrix2))) {
stop("The matrices have different dimensions.")
}
# Check if matrices are identical
identical_matrices <- identical(matrix1, matrix2)
if (identical_matrices) {
cat("The matrices are identical.\n")
} else {
cat("The matrices are not identical.\n")
# Find differing elements
differences <- which(matrix1 != matrix2, arr.ind = TRUE)
if (nrow(differences) > 0) {
cat("Differences found at the following positions:\n")
results <- data.frame(
Row = differences[, 1],
Column = differences[, 2],
Matrix1_Value = matrix1[differences],
Matrix2_Value = matrix2[differences]
)
print(results)
} else {
cat("No differing elements found.\n")
}
}
}
a <- compare_matrices(check1,weightMat_1)
a <- compare_matrices(check1[[1]],weightMat_1)
mean(c(0.042747580,0.02951641
))
setwd("/home/francescoc/Desktop/scGRN_simulation/R")
library(tidyverse)
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
library(rbenchmark)
library(reshape2)
library(gridExtra)
library(DiagrammeR)
library(pROC)
library(JRF)
library(DiagrammeRsvg)
library(rsvg)
source("dropo.R")
source("generate_adjacency.R")
source("simmetric.R")
source("pscores.R")
source("plotg.R")
source("compare_consensus.R")
source("create_consensus.R")
source("earlyj.R")
source("plotROC.R")
source("cutoff_adjacency.R")
source("infer_networks.R")
# Step 1: Set up the expression matrix
exprMatr <- matrix(sample(1:10, 100, replace=TRUE), nrow=20)
rownames(exprMatr) <- paste("Gene", 1:20, sep="")
colnames(exprMatr) <- paste("Sample", 1:5, sep="")
# Load the GENIE3 library
library(GENIE3)
# Set seed for reproducibility
set.seed(123)
# Step 2: Run GENIE3 with nCores=1
weightMat_1 <- GENIE3(exprMatr, nCores=1, verbose=TRUE)
weightMat_1 <- getLinkList(weightMat_1)
weightMat_1 <- simmetric(list(weightMat_1), weight_function = "mean")
weightMat_1 <- generate_adjacency(weightMat_1)
# Step 3: Run GENIE3 with nCores=4
set.seed(123)
weightMat_4 <- GENIE3(exprMatr, nCores=4, verbose=TRUE)
weightMat_4 <- getLinkList(weightMat_4)
weightMat_4 <- simmetric(list(weightMat_4), weight_function = "mean")
weightMat_4 <- generate_adjacency(weightMat_4)
# Step 3: Run GENIE3 with nCores=4
set.seed(123)
weightMat_8 <- GENIE3(exprMatr, nCores=8, verbose=TRUE)
weightMat_8 <- getLinkList(weightMat_8)
weightMat_8 <- simmetric(list(weightMat_8), weight_function = "mean")
weightMat_8 <- generate_adjacency(weightMat_8)
# Step 3: Run GENIE3 with nCores=4
set.seed(123)
weightMat_12 <- GENIE3(exprMatr, nCores=12, verbose=TRUE)
weightMat_12 <- getLinkList(weightMat_12)
weightMat_12 <- simmetric(list(weightMat_12), weight_function = "mean")
weightMat_12 <- generate_adjacency(weightMat_12)
library(GeneNet)
pcor <- ggm.estimate.pcor(t(exprMatr))
threshold <- 0.05
ground_truth <- ifelse(abs(pcor) > threshold, 1, 0)
weightMat_1 <- as.data.frame(weightMat_1[[1]])
weightMat_4 <- as.data.frame(weightMat_4[[1]])
weightMat_8 <- as.data.frame(weightMat_8[[1]])
weightMat_12 <- as.data.frame(weightMat_12[[1]])
truth_vec <- as.vector(ground_truth)
weightMat_1 <- weightMat_1[rownames(ground_truth),colnames(ground_truth)]
weightMat_4 <- weightMat_4[rownames(ground_truth),colnames(ground_truth)]
weightMat_8 <- weightMat_8[rownames(ground_truth),colnames(ground_truth)]
weightMat_12 <- weightMat_12[rownames(ground_truth),colnames(ground_truth)]
pred_vec_1 <- as.vector(as.matrix(weightMat_1))
pred_vec_4 <- as.vector(as.matrix(weightMat_4))
pred_vec_8 <- as.vector(as.matrix(weightMat_8))
pred_vec_12 <- as.vector(as.matrix(weightMat_12))
# Generate ROC curves
roc_1 <- roc(truth_vec, pred_vec_1, plot=FALSE)
roc_4 <- roc(truth_vec, pred_vec_4, plot=FALSE)
roc_8 <- roc(truth_vec, pred_vec_8, plot=FALSE)
roc_12 <- roc(truth_vec, pred_vec_12, plot=FALSE)
# Plot the first ROC curve with thicker lines and specified line type
plot(roc_1, col=adjustcolor("blue", alpha.f = 0.7), lwd=2, lty=1, main="ROC Comparison for GENIE3 with Different Cores", print.auc=F)
# Add the other ROC curves with distinct line types and colors
plot(roc_4, col=adjustcolor("red", alpha.f = 0.7), lwd=2, lty=2, add=TRUE, print.auc=F)
plot(roc_8, col=adjustcolor("orange", alpha.f = 0.7), lwd=2, lty=3, add=TRUE, print.auc=F)
plot(roc_12, col=adjustcolor("brown", alpha.f = 0.7), lwd=2, lty=4, add=TRUE, print.auc=F)
# Add legend with AUC values and distinguish lines by type
legend("bottomright",
legend=c(paste("nCores=1, AUC=", round(roc_1$auc, 2)),
paste("nCores=4, AUC=", round(roc_4$auc, 2)),
paste("nCores=8, AUC=", round(roc_8$auc, 2)),
paste("nCores=12, AUC=", round(roc_12$auc, 2))),
col=c("blue", "red", "orange", "brown"),
lty=1:4, lwd=2)
setwd("/home/francescoc/Desktop/scGRN_simulation/R")
library(tidyverse)
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
library(rbenchmark)
library(reshape2)
library(gridExtra)
library(DiagrammeR)
library(pROC)
library(JRF)
library(DiagrammeRsvg)
library(rsvg)
source("dropo.R")
source("generate_adjacency.R")
source("simmetric.R")
source("pscores.R")
source("plotg.R")
source("compare_consensus.R")
source("create_consensus.R")
source("earlyj.R")
source("plotROC.R")
source("cutoff_adjacency.R")
source("infer_networks.R")
# Step 1: Set up the expression matrix
exprMatr <- matrix(sample(1:10, 100, replace=TRUE), nrow=20)
rownames(exprMatr) <- paste("Gene", 1:20, sep="")
colnames(exprMatr) <- paste("Sample", 1:5, sep="")
# Load the GENIE3 library
library(GENIE3)
# Set seed for reproducibility
set.seed(123)
# Step 2: Run GENIE3 with nCores=1
weightMat_1 <- GENIE3(exprMatr, nCores=1, verbose=TRUE)
weightMat_1 <- getLinkList(weightMat_1)
weightMat_1 <- simmetric(list(weightMat_1), weight_function = "mean")
weightMat_1 <- generate_adjacency(weightMat_1)
# Step 3: Run GENIE3 with nCores=4
set.seed(123)
weightMat_4 <- GENIE3(exprMatr, nCores=4, verbose=TRUE)
weightMat_4 <- getLinkList(weightMat_4)
weightMat_4 <- simmetric(list(weightMat_4), weight_function = "mean")
weightMat_4 <- generate_adjacency(weightMat_4)
# Step 3: Run GENIE3 with nCores=4
set.seed(123)
weightMat_8 <- GENIE3(exprMatr, nCores=8, verbose=TRUE)
weightMat_8 <- getLinkList(weightMat_8)
weightMat_8 <- simmetric(list(weightMat_8), weight_function = "mean")
weightMat_8 <- generate_adjacency(weightMat_8)
# Step 3: Run GENIE3 with nCores=4
set.seed(123)
weightMat_12 <- GENIE3(exprMatr, nCores=12, verbose=TRUE)
weightMat_12 <- getLinkList(weightMat_12)
weightMat_12 <- simmetric(list(weightMat_12), weight_function = "mean")
weightMat_12 <- generate_adjacency(weightMat_12)
library(GeneNet)
pcor <- ggm.estimate.pcor(t(exprMatr))
threshold <- 0.05
ground_truth <- ifelse(abs(pcor) > threshold, 1, 0)
weightMat_1 <- as.data.frame(weightMat_1[[1]])
weightMat_4 <- as.data.frame(weightMat_4[[1]])
weightMat_8 <- as.data.frame(weightMat_8[[1]])
weightMat_12 <- as.data.frame(weightMat_12[[1]])
weightMat_1
truth_vec <- as.vector(ground_truth)
weightMat_1 <- weightMat_1[rownames(ground_truth),colnames(ground_truth)]
weightMat_4 <- weightMat_4[rownames(ground_truth),colnames(ground_truth)]
weightMat_8 <- weightMat_8[rownames(ground_truth),colnames(ground_truth)]
weightMat_12 <- weightMat_12[rownames(ground_truth),colnames(ground_truth)]
pred_vec_1 <- as.vector(as.matrix(weightMat_1))
pred_vec_4 <- as.vector(as.matrix(weightMat_4))
pred_vec_8 <- as.vector(as.matrix(weightMat_8))
pred_vec_12 <- as.vector(as.matrix(weightMat_12))
pred_vec_1
pred_vec_4
# Generate ROC curves
roc_1 <- roc(truth_vec, pred_vec_1, plot=FALSE)
roc_4 <- roc(truth_vec, pred_vec_4, plot=FALSE)
roc_8 <- roc(truth_vec, pred_vec_8, plot=FALSE)
roc_12 <- roc(truth_vec, pred_vec_12, plot=FALSE)
# Plot the first ROC curve with thicker lines and specified line type
plot(roc_1, col=adjustcolor("blue", alpha.f = 0.7), lwd=2, lty=1, main="ROC Comparison for GENIE3 with Different Cores", print.auc=F)
# Add the other ROC curves with distinct line types and colors
plot(roc_4, col=adjustcolor("red", alpha.f = 0.7), lwd=2, lty=2, add=TRUE, print.auc=F)
plot(roc_8, col=adjustcolor("orange", alpha.f = 0.7), lwd=2, lty=3, add=TRUE, print.auc=F)
plot(roc_12, col=adjustcolor("brown", alpha.f = 0.7), lwd=2, lty=4, add=TRUE, print.auc=F)
# Add legend with AUC values and distinguish lines by type
legend("bottomright",
legend=c(paste("nCores=1, AUC=", round(roc_1$auc, 2)),
paste("nCores=4, AUC=", round(roc_4$auc, 2)),
paste("nCores=8, AUC=", round(roc_8$auc, 2)),
paste("nCores=12, AUC=", round(roc_12$auc, 2))),
col=c("blue", "red", "orange", "brown"),
lty=1:4, lwd=2)
setwd("/home/francescoc/Desktop/scGRN_simulation/R")
library(tidyverse)
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
library(rbenchmark)
library(reshape2)
library(gridExtra)
library(DiagrammeR)
library(pROC)
library(JRF)
library(DiagrammeRsvg)
library(rsvg)
source("dropo.R")
source("generate_adjacency.R")
source("simmetric.R")
source("pscores.R")
source("plotg.R")
source("compare_consensus.R")
source("create_consensus.R")
source("earlyj.R")
source("plotROC.R")
source("cutoff_adjacency.R")
source("infer_networks.R")
# Step 1: Set up the expression matrix
exprMatr <- matrix(sample(1:10, 100, replace=TRUE), nrow=20)
rownames(exprMatr) <- paste("Gene", 1:20, sep="")
colnames(exprMatr) <- paste("Sample", 1:5, sep="")
# Load the GENIE3 library
library(GENIE3)
# Set seed for reproducibility
set.seed(12415)
# Step 2: Run GENIE3 with nCores=1
weightMat_1 <- GENIE3(exprMatr, nCores=1, verbose=TRUE)
weightMat_1 <- getLinkList(weightMat_1)
weightMat_1 <- simmetric(list(weightMat_1), weight_function = "mean")
weightMat_1 <- generate_adjacency(weightMat_1)
# Step 3: Run GENIE3 with nCores=4
set.seed(12415)
weightMat_4 <- GENIE3(exprMatr, nCores=4, verbose=TRUE)
weightMat_4 <- getLinkList(weightMat_4)
weightMat_4 <- simmetric(list(weightMat_4), weight_function = "mean")
weightMat_4 <- generate_adjacency(weightMat_4)
# Step 3: Run GENIE3 with nCores=4
set.seed(12415)
weightMat_8 <- GENIE3(exprMatr, nCores=8, verbose=TRUE)
weightMat_8 <- getLinkList(weightMat_8)
weightMat_8 <- simmetric(list(weightMat_8), weight_function = "mean")
weightMat_8 <- generate_adjacency(weightMat_8)
# Step 3: Run GENIE3 with nCores=4
set.seed(12415)
weightMat_12 <- GENIE3(exprMatr, nCores=12, verbose=TRUE)
weightMat_12 <- getLinkList(weightMat_12)
weightMat_12 <- simmetric(list(weightMat_12), weight_function = "mean")
weightMat_12 <- generate_adjacency(weightMat_12)
library(GeneNet)
pcor <- ggm.estimate.pcor(t(exprMatr))
threshold <- 0.05
ground_truth <- ifelse(abs(pcor) > threshold, 1, 0)
weightMat_1 <- as.data.frame(weightMat_1[[1]])
weightMat_4 <- as.data.frame(weightMat_4[[1]])
weightMat_8 <- as.data.frame(weightMat_8[[1]])
weightMat_12 <- as.data.frame(weightMat_12[[1]])
truth_vec <- as.vector(ground_truth)
weightMat_1 <- weightMat_1[rownames(ground_truth),colnames(ground_truth)]
weightMat_4 <- weightMat_4[rownames(ground_truth),colnames(ground_truth)]
weightMat_8 <- weightMat_8[rownames(ground_truth),colnames(ground_truth)]
weightMat_12 <- weightMat_12[rownames(ground_truth),colnames(ground_truth)]
pred_vec_1 <- as.vector(as.matrix(weightMat_1))
pred_vec_4 <- as.vector(as.matrix(weightMat_4))
pred_vec_8 <- as.vector(as.matrix(weightMat_8))
pred_vec_12 <- as.vector(as.matrix(weightMat_12))
# Generate ROC curves
roc_1 <- roc(truth_vec, pred_vec_1, plot=FALSE)
roc_4 <- roc(truth_vec, pred_vec_4, plot=FALSE)
roc_8 <- roc(truth_vec, pred_vec_8, plot=FALSE)
roc_12 <- roc(truth_vec, pred_vec_12, plot=FALSE)
# Plot the first ROC curve with thicker lines and specified line type
plot(roc_1, col=adjustcolor("blue", alpha.f = 0.7), lwd=2, lty=1, main="ROC Comparison for GENIE3 with Different Cores", print.auc=F)
# Add the other ROC curves with distinct line types and colors
plot(roc_4, col=adjustcolor("red", alpha.f = 0.7), lwd=2, lty=2, add=TRUE, print.auc=F)
plot(roc_8, col=adjustcolor("orange", alpha.f = 0.7), lwd=2, lty=3, add=TRUE, print.auc=F)
plot(roc_12, col=adjustcolor("brown", alpha.f = 0.7), lwd=2, lty=4, add=TRUE, print.auc=F)
# Add legend with AUC values and distinguish lines by type
legend("bottomright",
legend=c(paste("nCores=1, AUC=", round(roc_1$auc, 2)),
paste("nCores=4, AUC=", round(roc_4$auc, 2)),
paste("nCores=8, AUC=", round(roc_8$auc, 2)),
paste("nCores=12, AUC=", round(roc_12$auc, 2))),
col=c("blue", "red", "orange", "brown"),
lty=1:4, lwd=2)
