library(pROC)
shuffle_matrix <- function(matrix) {
shuffled_matrix <- matrix
for (col in 1:ncol(matrix)) {
shuffled_matrix[, col] <- sample(matrix[, col])
}
return(shuffled_matrix)
}
calculate_metrics <- function(binary_matrix, ground_truth) {
y_true <- as.vector(as.matrix(ground_truth))
y_pred <- as.vector(as.matrix(binary_matrix))
# Calculate TP, FN, TN, FP
TP <- sum((y_pred == 1) & (y_true == 1))
FN <- sum((y_pred == 0) & (y_true == 1))
TN <- sum((y_pred == 0) & (y_true == 0))
FP <- sum((y_pred == 1) & (y_true == 0))
# Calculate sensitivity and specificity
sensitivity <- ifelse((TP + FN) > 0, TP / (TP + FN), 0)
specificity <- ifelse((TN + FP) > 0, TN / (TN + FP), 0)
return(list(TP = TP, FN = FN, sensitivity = sensitivity, specificity = specificity))
}
generate_roc_and_find_cutoff <- function(original_matrix, ground_truth, n_shuffles = 100, cutoffs = seq(0, 1, length.out = 100)) {
shuffled_matrices <- lapply(1:n_shuffles, function(x) shuffle_matrix(original_matrix))
roc_results <- list()
for (cutoff in cutoffs) {
binary_original <- (original_matrix >= cutoff) * 1
original_metrics <- calculate_metrics(binary_original, ground_truth)
roc_data <- data.frame(Cutoff = cutoff, Sensitivity = original_metrics$sensitivity, Specificity = original_metrics$specificity, Type = "Original")
for (shuffled_matrix in shuffled_matrices) {
binary_shuffled <- (shuffled_matrix >= cutoff) * 1
shuffled_metrics <- calculate_metrics(binary_shuffled, ground_truth)
roc_data <- rbind(roc_data, data.frame(Cutoff = cutoff, Sensitivity = shuffled_metrics$sensitivity, Specificity = shuffled_metrics$specificity, Type = "Shuffled"))
}
roc_results[[as.character(cutoff)]] <- roc_data
}
roc_combined <- do.call(rbind, roc_results)
roc_summary <- aggregate(cbind(Sensitivity, Specificity) ~ Cutoff, data = roc_combined, function(x) mean(x[x != 0], na.rm = TRUE))
roc_curve <- roc(roc_combined$Sensitivity, roc_combined$Specificity, plot = TRUE, main = "ROC Curve for Multiple Shuffles")
optimal_cutoff <- roc_summary$Cutoff[which.max(roc_summary$Sensitivity + roc_summary$Specificity)]
return(list(optimal_cutoff = optimal_cutoff, roc_summary = roc_summary, roc_curve = roc_curve))
}
original_matrix <- as.matrix(read.csv("checkadj.txt", sep="\t", row.names = 1))
ground_truth_matrix <- as.matrix(read.csv("/home/francescoc/Desktop/scGRN_simulation/data/adjacency_matrix.csv", row.names = 1))
results <- generate_roc_and_find_cutoff(original_matrix, ground_truth_matrix, n_shuffles = 1000, cutoffs = seq(0, max(original_matrix), length.out = 100))
cat("Optimal cutoff based on ROC analysis:", results$optimal_cutoff, "\n")
library(pROC)
shuffle_matrix <- function(matrix) {
shuffled_matrix <- matrix
for (col in 1:ncol(matrix)) {
shuffled_matrix[, col] <- sample(matrix[, col])
}
return(shuffled_matrix)
}
calculate_metrics <- function(binary_matrix, ground_truth) {
y_true <- as.vector(as.matrix(ground_truth))
y_pred <- as.vector(as.matrix(binary_matrix))
# Calculate TP, FN, TN, FP
TP <- sum((y_pred == 1) & (y_true == 1))
FN <- sum((y_pred == 0) & (y_true == 1))
TN <- sum((y_pred == 0) & (y_true == 0))
FP <- sum((y_pred == 1) & (y_true == 0))
# Calculate sensitivity and specificity
sensitivity <- ifelse((TP + FN) > 0, TP / (TP + FN), 0)
specificity <- ifelse((TN + FP) > 0, TN / (TN + FP), 0)
return(list(TP = TP, FN = FN, sensitivity = sensitivity, specificity = specificity))
}
generate_roc_and_find_cutoff <- function(original_matrix, ground_truth, n_shuffles = 100, cutoffs = seq(0, 1, length.out = 100)) {
shuffled_matrices <- lapply(1:n_shuffles, function(x) shuffle_matrix(original_matrix))
roc_results <- list()
for (cutoff in cutoffs) {
binary_original <- (original_matrix >= cutoff) * 1
original_metrics <- calculate_metrics(binary_original, ground_truth)
roc_data <- data.frame(Cutoff = cutoff, Sensitivity = original_metrics$sensitivity, Specificity = original_metrics$specificity, Type = "Original")
for (shuffled_matrix in shuffled_matrices) {
binary_shuffled <- (shuffled_matrix >= cutoff) * 1
shuffled_metrics <- calculate_metrics(binary_shuffled, ground_truth)
roc_data <- rbind(roc_data, data.frame(Cutoff = cutoff, Sensitivity = shuffled_metrics$sensitivity, Specificity = shuffled_metrics$specificity, Type = "Shuffled"))
}
roc_results[[as.character(cutoff)]] <- roc_data
}
roc_combined <- do.call(rbind, roc_results)
roc_summary <- aggregate(cbind(Sensitivity, Specificity) ~ Cutoff, data = roc_combined, function(x) mean(x[x != 0], na.rm = TRUE))
roc_curve <- roc(roc_combined$Sensitivity, roc_combined$Specificity, plot = TRUE, main = "ROC Curve for Multiple Shuffles")
optimal_cutoff <- roc_summary$Cutoff[which.max(roc_summary$Sensitivity + roc_summary$Specificity)]
return(list(optimal_cutoff = optimal_cutoff, roc_summary = roc_summary, roc_curve = roc_curve))
}
original_matrix <- as.matrix(read.csv("checkadj.txt", sep="\t", row.names = 1))
original_matrix <- as.matrix(read.csv("/home/francescoc/checkadj.txt", sep="\t", row.names = 1))
ground_truth_matrix <- as.matrix(read.csv("/home/francescoc/Desktop/scGRN_simulation/data/adjacency_matrix.csv", row.names = 1))
results <- generate_roc_and_find_cutoff(original_matrix, ground_truth_matrix, n_shuffles = 1000, cutoffs = seq(0, max(original_matrix), length.out = 100))
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/R")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()
link_list_genie3_list <- readRDS("./../analysis/genie3_network_list.RDS")
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/R")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable", timing = TRUE)
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
library(rbenchmark)
library(reshape2)
library(gridExtra)
library(DiagrammeR)
source("dropo.R")
source("generate_adjacency.R")
source("adj_cutoff.R")
source("simmetric.R")
source("pscores.R")
source("plotg.R")
source("compare_consensus.R")
source("earlyj.R")
DiagrammeR::grViz("
digraph biological_workflow {
# Set up the graph attributes
graph [layout = dot, rankdir = TB]
# Define consistent node styles
node [shape = rectangle, style = filled, color = lightblue, fontsize = 12]
# Define nodes for each step
StartNode [label = 'Biological String Regulatory Network', shape = oval, color = forestgreen, fontcolor = black]
AdjacencyMatrix [label = 'Create Adjacency Matrix', shape = rectangle, color = lightblue]
SimulateData [label = 'Simulate Single-Cell Data', shape = rectangle, color = lightyellow]
# Reconstruction using Three Packages
GENIE3Step [label = 'GENIE3: Calculate Gene Weights', shape = rectangle, color = lightpink]
GRNBoostStep [label = 'GRNBoost2: Calculate Gene Weights', shape = rectangle, color = lightpink]
Learn2CountStep [label = 'learn2count: Calculate Gene Weights', shape = rectangle, color = lightpink]
# Generate Adjacency Matrices for Each Package
GENIE3Adj [label = 'GENIE3: Generate Adjacency Matrix', shape = rectangle, color = khaki]
GRNBoostAdj [label = 'GRNBoost2: Generate Adjacency Matrix', shape = rectangle, color = khaki]
Learn2CountAdj [label = 'learn2count: Generate Adjacency Matrix', shape = rectangle, color = khaki]
# Symmetrize Step
Symmetrize [label = 'Symmetrize Adjacency Matrix', shape = rectangle, color = lightyellow]
# Comparison with Ground Truth
Compare [label = 'Compare with Ground Truth Adjacency', shape = rectangle, color = salmon]
# Analysis and Visualization
Analysis [label = 'Analysis and Visualization', shape = rectangle, color = lightcoral]
# Define the workflow structure
StartNode -> AdjacencyMatrix
AdjacencyMatrix -> SimulateData
SimulateData -> GENIE3Step
SimulateData -> GRNBoostStep
SimulateData -> Learn2CountStep
GENIE3Step -> GENIE3Adj
GRNBoostStep -> GRNBoostAdj
Learn2CountStep -> Learn2CountAdj
GENIE3Adj -> Symmetrize
GRNBoostAdj -> Symmetrize
Learn2CountAdj -> Symmetrize
Symmetrize -> Compare
Compare -> Analysis
}
")
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()
link_list_genie3_list <- readRDS("./../analysis/genie3_network_list.RDS")
link_list_genie3_list[[ยน]]
link_list_genie3_list[[1]]
interaction_data$ground_truth <- mapply(function(reg, tgt) {
return(ifelse(adjacency_matrix[reg, tgt] == 1, 1, 0))
}, interaction_data$regulatoryGene, interaction_data$targetGene)
link_list_genie3_list[[1]]$ground_truth <- mapply(function(reg, tgt) {
return(ifelse(adjacency_matrix[reg, tgt] == 1, 1, 0))
}, link_list_genie3_list[[1]]$regulatoryGene, link_list_genie3_list[[1]]$targetGene)
link_list_genie3_list[[1]]$ground_truth <- mapply(function(reg, tgt) {
return(ifelse(adjm[reg, tgt] == 1, 1, 0))
}, link_list_genie3_list[[1]]$regulatoryGene, link_list_genie3_list[[1]]$targetGene)
link_list_genie3_list[[1]]
# Calculate the ROC curve
roc_curve <- roc(link_list_genie3_list[[1]]$ground_truth, link_list_genie3_list[[1]]$weight)
# Plot the ROC curve
plot(roc_curve, main = "ROC Curve for Gene Interactions", col = "blue", lwd = 2)
# Print the AUC
auc_value <- auc(roc_curve)
print(paste("AUC:", auc_value))
