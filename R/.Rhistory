scores.grn.early$Statistics %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "scores")
plots <- plotg(sgrnb_early_adj)
ajm_compared <- compare_consensus(sgrnb_early_adj[[1]], adjm)
set.seed(1234)
tictoc::tic("ZILGM early")
zilgm_late <- infer_networks(count_matrices_list = early_matrix, method = "ZILGM", adjm = adjm)
saveRDS(zilgm_late, "./../analysis/zilgm_early.RDS")
execution_times[['ZILGM early']] <- tictoc::toc(log = TRUE)$toc[[1]]
est_graphs <- zilgm_late$network_results
lambdas <- zilgm_late$lambda_results
scores.zilgm1 <- pscores(adjm, lambdas[[1]])
m1 <- scores.zilgm1$Statistics %>% mutate(K="M1")
ggplot(m1, aes(x=FPR, y=TPR, color=K)) +
geom_point() +
geom_line(size=1.2) +
labs(x="False Positive Rate (1 - Specificity)",
y="True Positive Rate (Sensitivity)") +
theme_minimal() +
theme(legend.position = "bottom")
scores.zilgm.early <- pscores(adjm, list(as.matrix(est_graph)))
est_graphs
scores.zilgm.early <- pscores(adjm, est_graph))
scores.zilgm.early <- pscores(adjm, est_graph)
scores.zilgm.early <- pscores(adjm, est_graphs)
scores.zilgm.early$Statistics %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "scores")
ajm_compared <- compare_consensus(est_graphs, adjm)
ajm_compared <- compare_consensus(est_graphs[[1]], adjm)
mplot <- list()
for (k in c("TPR", "FPR", "Precision", "F1", "Accuracy")) {
mplot[[k]] <- data.frame(
GENIE3_late = scores.genie3.late$Statistics[[k]],
GENIE3_early = scores.genie3.early$Statistics[[k]],
GRNBoost2_late = scores.grn.late$Statistics[[k]],
GRNBoost2_early = scores.grn.early$Statistics[[k]],
ZILGM_late = scores.zilgm.late$Statistics[[k]],
ZILGM_early = scores.zilgm.early$Statistics[[k]]#,
#JRF = scores.jrf$Statistics[[k]]
)
}
# Convert mplot list into a long data frame for ggplot2
plot_data <- bind_rows(lapply(names(mplot), function(metric) {
data.frame(
Metric = metric,
Method = names(mplot[[metric]]),
Value = as.numeric(mplot[[metric]][1, ])
)
}))
# Extract method groups for coloring and order the Method factor so JRF appears last
plot_data <- plot_data %>%
mutate(Method_Group = case_when(
grepl("GENIE3", Method) ~ "GENIE3",
grepl("GRNBoost2", Method) ~ "GRNBoost2",
grepl("ZILGM", Method) ~ "ZILGM",
grepl("JRF", Method) ~ "JRF"
)) %>%
mutate(Method = factor(Method, levels = c(
"GENIE3_early", "GENIE3_late",
"GRNBoost2_early", "GRNBoost2_late",
"ZILGM_early", "ZILGM_late",
"JRF"  # Ensure JRF is last
)))
# Define color palette for each method group
method_colors <- c("GENIE3" = "darkblue", "GRNBoost2" = "darkgreen", "ZILGM" = "orange", "JRF" = "red")
# Create a separate ggplot for each metric, with y-axis limits set to 0-1 and no legend
plots <- lapply(unique(plot_data$Metric), function(metric) {
# Determine if x-axis text should be displayed
show_x_text <- metric %in% c("Accuracy", "F1")
ggplot(plot_data %>% filter(Metric == metric), aes(x = Method, y = Value, fill = Method_Group)) +
geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
labs(title = metric, y = "Value", x = NULL) +
scale_y_continuous(limits = c(0, 1)) +  # Set y-axis limits
scale_fill_manual(values = method_colors) +
theme_minimal() +
theme(
axis.text.x = if (show_x_text) element_text(angle = 45, hjust = 1) else element_blank(),
axis.title.x = element_blank(),
legend.position = "none"  # Remove legend from individual plots
)
})
# Add time data to the plotting dataset
time_data <- data.frame(
Method = names(execution_times),
Time_in_Hours = unlist(execution_times) / 3600
)
time_data$Time_in_Minutes <- time_data$Time_in_Hours * 60
time_data <- time_data[order(time_data$Time_in_Hours), ]
time_data$Method <- factor(time_data$Method, levels = time_data$Method)
# Assign group colors to time_data for consistency
time_data <- time_data %>%
mutate(Method_Group = case_when(
grepl("GENIE3", Method) ~ "GENIE3",
grepl("GRNBoost2", Method) ~ "GRNBoost2",
grepl("ZILGM", Method) ~ "ZILGM",
grepl("JRF", Method) ~ "JRF"
))
# Create the execution time plot
time_plot <- ggplot(time_data, aes(x = Method, y = Time_in_Hours, fill = Method_Group)) +
geom_bar(stat = "identity") +
geom_text(aes(label = sprintf("%.1f min", Time_in_Minutes)), vjust = -0.5) +
labs(title = "Execution Time for Each Method", y = "Time (Hours)", x = NULL) +
scale_fill_manual(values = method_colors) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none"
)
# Add the execution time plot to the existing list of plots
plots <- append(plots, list(time_plot))
# Adjust the layout to accommodate the extra plot
final_plot <- (plots[[1]] | plots[[2]]) /
(plots[[3]] | plots[[4]]) /
(plots[[5]] | plots[[6]]) +
plot_layout(guides = "collect") &
theme(legend.position = "bottom")
print(final_plot)
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/R")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable", timing = TRUE)
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
library(rbenchmark)
library(reshape2)
library(gridExtra)
library(DiagrammeR)
library(pROC)
library(JRF)
library(DiagrammeRsvg)
library(rsvg)
library(RColorBrewer)
library(rbenchmark)
library(ZILGM)
library(patchwork)
use_python("/usr/bin/python3", required = TRUE)
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")
execution_times <- list()
source("generate_adjacency.R")
source("symmetrize.R")
source("pscores.R")
source("plotg.R")
source("compare_consensus.R")
source("create_consensus.R")
source("earlyj.R")
source("plotROC.R")
source("cutoff_adjacency.R")
source("infer_networks.R")
grViz_output <- DiagrammeR::grViz("
digraph biological_workflow {
# Set up the graph attributes
graph [layout = dot, rankdir = TB]
# Define consistent node styles
node [shape = rectangle, style = filled, color = lightblue, fontsize = 12]
# Define nodes for each step
StartNode [label = 'Ground Thruth - String Regulatory Network', shape = oval, color = seagreen, fontcolor = black]
AdjacencyMatrix [label = 'Thruth Adjacency Matrix', shape = rectangle, color = seagreen]
SimulateData [label = 'Simulate Single-Cell Data', shape = rectangle, color = goldenrod]
# Reconstruction using Three Packages
LateIntegration [label = 'Late\nIntegration', shape = oval, color = khaki]
EarlyIntegration [label = 'Early\nIntegration', shape = oval, color = khaki]
Jointanalysis [label = 'Joint\nanalysis', shape = oval, color = khaki]
# Process
earlyj [label = 'earlyj.R', shape=diamond, color=lightblue, fontcolor=black]
networkinference [label = 'infer_networks.R\nGENIE3\nGRNBoost2\nZILGM\nJRF', shape = rectangle, color = goldenrod, fontcolor=black]
symmetrize [label = 'symmetrize.R', shape = rectangle, color = goldenrod, fontcolor=black]
plotROC [label = 'plotROC.R', shape=diamond, color=lightblue, fontcolor=black]
generateadjacency [label='generate_adjacency.R\nWeighted Adjacency', shape=rectangle, color=goldenrod, fontcolor=black]
cutoffadjacency [label='cutoff_adjacency.R\nBinary Adjacency', shape=rectangle, color=goldenrod, fontcolor=black]
pscores [label='pscores.R\nTPR\nFPR\nF1\nAccuracy\nPrecision', shape=diamond, color=lightblue, fontcolor=black]
voting [label='Voting\nUnion\nIntersection', shape=diamond, color=lightblue, fontcolor=black]
plotgcompare  [label='plotg.R\ncompare_consesus.R\nPlot Graphs', shape=rectangle, color=goldenrod, fontcolor=black]
# Define the workflow structure
StartNode -> AdjacencyMatrix
AdjacencyMatrix -> SimulateData
SimulateData -> LateIntegration
SimulateData -> EarlyIntegration
SimulateData -> Jointanalysis
EarlyIntegration -> earlyj
earlyj -> networkinference
LateIntegration -> networkinference
Jointanalysis -> networkinference
networkinference -> symmetrize
symmetrize -> plotROC
symmetrize -> generateadjacency
generateadjacency -> cutoffadjacency
cutoffadjacency -> pscores
cutoffadjacency -> voting
voting -> plotgcompare
voting -> pscores
}
")
svg_code <- export_svg(grViz_output)
rsvg::rsvg_png(charToRaw(svg_code), "./../analysis/flowchart.png")
grViz_output
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()
diag(adjm) <- 0
adjm %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "Ground Truth")
gtruth <- igraph::graph_from_adjacency_matrix(adjm, mode = "undirected", diag = F)
num_nodes <- vcount(gtruth)
num_edges <- ecount(gtruth)
set.seed(1234)
plot(gtruth,
main = paste("Ground Truth\nNodes:", num_nodes, "Edges:", num_edges),
vertex.label.color = "black",
vertex.size = 6,
edge.width = 2,
vertex.label = NA,
vertex.color = "steelblue",
layout = igraph::layout_with_fr)
ncell <- 500
nodes <- nrow(adjm)
set.seed(1130)
mu_values <- c(3, 6, 9)
count_matrices <- lapply(1:3, function(i) {
set.seed(1130 + i)
mu_i <- mu_values[i]
count_matrix_i <- simdata(n = ncell, p = nodes, B = adjm, family = "ZINB",
mu = mu_i, mu_noise = 1, theta = 0.5, pi = 0.2)
count_matrix_df <- as.data.frame(count_matrix_i)
colnames(count_matrix_df) <- colnames(adjm)
rownames(count_matrix_df) <- paste("cell", 1:nrow(count_matrix_df), sep = "")
return(count_matrix_df)
})
count_matrices[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "Simulated count matrix")
saveRDS(count_matrices, "./../analysis/count_matrices.RDS")
jrf_matrices <- lapply(count_matrices, t)
jrf_matrices_norm <- lapply(jrf_matrices,function(x) {
(x - mean(x)) / sd(x)
})
genes <- rownames(jrf_matrices_norm[[1]])
set.seed(1234)
tictoc::tic("JRF_out")
netout <- JRF(X = jrf_matrices_norm,
genes.name = genes,
ntree = 500,
mtry = round(sqrt(length(genes) - 1)))
execution_times[['JRF_out']] <- tictoc::toc(log = TRUE)$toc[[1]]
netout %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "JRF output")
check1 <- netout
#https://cran.r-project.org/src/contrib/Archive/JRF/
#install.packages("/home/francescoc/Downloads/JRF_0.1-4.tar.gz", repos = NULL, type = "source")
set.seed(1234)
tictoc::tic("JRF")
jrf_mat <- infer_networks(count_matrices, method="JRF")
execution_times[['JRF']] <- tictoc::toc(log = TRUE)$toc[[1]]
jrf_mat[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "JRF output")
1162.683/60
1221.838/60
identical(jrf_matrices1[[1]], check1)
identical(jrf_mat[[1]], check1)
jrf_matrices <- lapply(count_matrices, t)
jrf_matrices_norm <- lapply(jrf_matrices,function(x) {
(x - mean(x)) / sd(x)
})
genes <- rownames(jrf_matrices_norm[[1]])
set.seed(1234)
out.perm <- Run_permutation(jrf_matrices_norm,mtry=round(sqrt(length(genes)-1)),ntree=500, genes,5)
myJRF_network <- function(out.jrf, out.perm, TH) {
nclasses <- dim(out.perm)[3]
M <- dim(out.perm)[2]
out <- vector("list", nclasses)
for (net in 1:nclasses) {
j.np <- sort(out.jrf[, 2 + net], decreasing = TRUE)
FDR <- matrix(0, dim(out.perm)[1], 1)
th <- NULL
for (s in 1:length(j.np)) {
FP <- sum(sum(out.perm[, , net] >= j.np[s])) / M
FDR[s] <- FP / s
if (FDR[s] > TH) {
th <- j.np[s]
break
}
}
out[[net]] <- out.jrf[out.jrf[, 2 + net] > th, seq(1, 2)]
}
return(out)
}
mynet <- myJRF_network(jrf_mat[[1]],out.perm,0.05)
mynet
jrf_list <- list()
importance_columns <- grep("importance", names(jrf_mat[[1]]), value = TRUE)
for (i in seq_along(importance_columns)) {
# Select the 'gene1', 'gene2', and the current 'importance' column
df <- jrf_mat[[1]][, c("gene1", "gene2", importance_columns[i])]
# Rename the importance column to its original name (e.g., importance1, importance2, etc.)
names(df)[3] <- importance_columns[i]
# Add the data frame to the output list
jrf_list[[i]] <- df
}
saveRDS(jrf_list, "./../analysis/jrf.RDS")
jrf_list[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "JRF output")
jrf_wadj <- generate_adjacency(jrf_list, ground.truth = adjm)
sjrf_wadj <- symmetrize(jrf_wadj, weight_function = "mean")
plotROC(sjrf_wadj, adjm, plot_title = "ROC curve - JRF Late Integration")
help(PCzinb)
head(as.matrix(count_matrices[[1]])
)
tictoc::tic()
est <- PCzinb(as.matrix(count_matrices[[1]]), method="zinb1", maxcard=2, alpha=0.1)
knitr::opts_chunk$set("/home/francescoc/Desktop/scGRN_simulation/R")
knitr::opts_chunk$set(warning=FALSE, message=FALSE, fig.height=5, fig.width=10, fig.align = "center", class.source = "foldable", timing = TRUE)
library(GENIE3)
library(doParallel)
library(igraph)
library(tidyverse)
library(DT)
library(reticulate)
library(learn2count)
library(rbenchmark)
library(reshape2)
library(gridExtra)
library(DiagrammeR)
library(pROC)
library(JRF)
library(DiagrammeRsvg)
library(rsvg)
library(RColorBrewer)
library(rbenchmark)
library(ZILGM)
library(patchwork)
use_python("/usr/bin/python3", required = TRUE)
arboreto <- import("arboreto.algo")
pandas <- import("pandas")
numpy <- import("numpy")
execution_times <- list()
source("generate_adjacency.R")
source("symmetrize.R")
source("pscores.R")
source("plotg.R")
source("compare_consensus.R")
source("create_consensus.R")
source("earlyj.R")
source("plotROC.R")
source("cutoff_adjacency.R")
source("infer_networks.R")
grViz_output <- DiagrammeR::grViz("
digraph biological_workflow {
# Set up the graph attributes
graph [layout = dot, rankdir = TB]
# Define consistent node styles
node [shape = rectangle, style = filled, color = lightblue, fontsize = 12]
# Define nodes for each step
StartNode [label = 'Ground Thruth - String Regulatory Network', shape = oval, color = seagreen, fontcolor = black]
AdjacencyMatrix [label = 'Thruth Adjacency Matrix', shape = rectangle, color = seagreen]
SimulateData [label = 'Simulate Single-Cell Data', shape = rectangle, color = goldenrod]
# Reconstruction using Three Packages
LateIntegration [label = 'Late\nIntegration', shape = oval, color = khaki]
EarlyIntegration [label = 'Early\nIntegration', shape = oval, color = khaki]
Jointanalysis [label = 'Joint\nanalysis', shape = oval, color = khaki]
# Process
earlyj [label = 'earlyj.R', shape=diamond, color=lightblue, fontcolor=black]
networkinference [label = 'infer_networks.R\nGENIE3\nGRNBoost2\nZILGM\nJRF', shape = rectangle, color = goldenrod, fontcolor=black]
symmetrize [label = 'symmetrize.R', shape = rectangle, color = goldenrod, fontcolor=black]
plotROC [label = 'plotROC.R', shape=diamond, color=lightblue, fontcolor=black]
generateadjacency [label='generate_adjacency.R\nWeighted Adjacency', shape=rectangle, color=goldenrod, fontcolor=black]
cutoffadjacency [label='cutoff_adjacency.R\nBinary Adjacency', shape=rectangle, color=goldenrod, fontcolor=black]
pscores [label='pscores.R\nTPR\nFPR\nF1\nAccuracy\nPrecision', shape=diamond, color=lightblue, fontcolor=black]
voting [label='Voting\nUnion\nIntersection', shape=diamond, color=lightblue, fontcolor=black]
plotgcompare  [label='plotg.R\ncompare_consesus.R\nPlot Graphs', shape=rectangle, color=goldenrod, fontcolor=black]
# Define the workflow structure
StartNode -> AdjacencyMatrix
AdjacencyMatrix -> SimulateData
SimulateData -> LateIntegration
SimulateData -> EarlyIntegration
SimulateData -> Jointanalysis
EarlyIntegration -> earlyj
earlyj -> networkinference
LateIntegration -> networkinference
Jointanalysis -> networkinference
networkinference -> symmetrize
symmetrize -> plotROC
symmetrize -> generateadjacency
generateadjacency -> cutoffadjacency
cutoffadjacency -> pscores
cutoffadjacency -> voting
voting -> plotgcompare
voting -> pscores
}
")
svg_code <- export_svg(grViz_output)
rsvg::rsvg_png(charToRaw(svg_code), "./../analysis/flowchart.png")
grViz_output
adjm <- read.table("./../data/adjacency_matrix.csv", header = T, row.names = 1, sep = ",") %>% as.matrix()
diag(adjm) <- 0
adjm %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "Ground Truth")
gtruth <- igraph::graph_from_adjacency_matrix(adjm, mode = "undirected", diag = F)
num_nodes <- vcount(gtruth)
num_edges <- ecount(gtruth)
set.seed(1234)
plot(gtruth,
main = paste("Ground Truth\nNodes:", num_nodes, "Edges:", num_edges),
vertex.label.color = "black",
vertex.size = 6,
edge.width = 2,
vertex.label = NA,
vertex.color = "steelblue",
layout = igraph::layout_with_fr)
ncell <- 500
nodes <- nrow(adjm)
set.seed(1130)
mu_values <- c(3, 6, 9)
count_matrices <- lapply(1:3, function(i) {
set.seed(1130 + i)
mu_i <- mu_values[i]
count_matrix_i <- simdata(n = ncell, p = nodes, B = adjm, family = "ZINB",
mu = mu_i, mu_noise = 1, theta = 0.5, pi = 0.2)
count_matrix_df <- as.data.frame(count_matrix_i)
colnames(count_matrix_df) <- colnames(adjm)
rownames(count_matrix_df) <- paste("cell", 1:nrow(count_matrix_df), sep = "")
return(count_matrix_df)
})
count_matrices[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "Simulated count matrix")
saveRDS(count_matrices, "./../analysis/count_matrices.RDS")
set.seed(1234)
tictoc::tic("GENIE3 late")
genie3_late <- infer_networks(count_matrices, method="GENIE3")
saveRDS(genie3_late, "./../analysis/genie3_late.RDS")
execution_times[['GENIE3 late']] <- tictoc::toc(log = TRUE)$toc[[1]]
genie3_late[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GENIE3 output")
source("plotROC.R")
genie3_late_wadj <- generate_adjacency(genie3_late, ground.truth = adjm)
sgenie3_late_wadj <- symmetrize(genie3_late_wadj, weight_function = "mean")
plotROC(sgenie3_late_wadj, adjm, plot_title = "ROC curve - GENIE3 Late Integration")
sgenie3_late_wadj[[1]] %>%
datatable(extensions = 'Buttons',
options = list(
dom = 'Bfrtip',
buttons = c('csv', 'excel'),
scrollX = TRUE,
pageLength = 10),
caption = "GENIE3 symmetrize output")
sgenie3_late_adj <- cutoff_adjacency(count_matrices = count_matrices,
weighted_adjm_list = sgenie3_late_wadj,
ground.truth = adjm,
n = 3,
method = "GENIE3")
source("~/.active-rstudio-document", echo=TRUE)
devtools::install_github("ngsFC/NodeVerse")
