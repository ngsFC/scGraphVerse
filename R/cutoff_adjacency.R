#' Threshold Adjacency Matrices Based on Shuffled Network Quantiles
#'
#' Applies a cutoff to weighted adjacency matrices using a percentile estimated
#' from shuffled versions of the original expression matrices. Supports inference methods
#' \code{"GENIE3"}, \code{"GRNBoost2"}, and \code{"JRF"}.
#'
#' @param count_matrices A list of expression matrices (genes × cells) or \linkS4class{Seurat} or \linkS4class{SingleCellExperiment} objects.
#' @param weighted_adjm_list A list of weighted adjacency matrices (one per expression matrix) to threshold.
#' @param n Integer. Number of shuffled replicates generated per original expression matrix.
#' @param method Character string. One of \code{"GENIE3"}, \code{"GRNBoost2"}, or \code{"JRF"}.
#' @param quantile_threshold Numeric. The quantile used to define the cutoff. Default is \code{0.99}.
#' @param weight_function Character string or function used to symmetrize adjacency matrices (\code{"mean"}, \code{"max"}, etc.).
#' @param total_cores Integer. Total number of CPU cores to use for parallelism.
#' @param grnboost_modules Python modules needed for \code{GRNBoost2} if using reticulate.
#' @param seed Integer. Random seed for reproducibility. Default is \code{123}.
#' @param debug Logical. If \code{TRUE}, prints detailed progress messages and cutoff values. Default is \code{FALSE}.
#'
#' @return A list of binary (thresholded) adjacency matrices, each corresponding to an input weighted matrix.
#'
#' @details
#' For each input expression matrix, \code{n} shuffled versions are generated by randomly permuting each gene's expression across cells.
#' Network inference is performed on the shuffled matrices, and a cutoff is determined as the specified quantile (\code{quantile_threshold})
#' of the resulting edge weights. The final binary adjacency matrices are obtained by thresholding the original weighted matrices
#' using the estimated cutoffs.
#'
#' Parallelism is handled via \pkg{BiocParallel}. Nested parallelism is supported for methods like \code{GENIE3} and \code{JRF}.
#'
#' @importFrom BiocParallel bplapply MulticoreParam SerialParam bpworkers bpparam
#' @importFrom Seurat GetAssayData
#' @importFrom SummarizedExperiment assay
#' @export
#'
#' @examples
#' set.seed(123)
#' # Simulate small expression matrices
#' mat1 <- matrix(rpois(100, lambda = 5), nrow = 10, ncol = 10)
#' mat2 <- matrix(rpois(100, lambda = 5), nrow = 10, ncol = 10)
#' rownames(mat1) <- paste0("Gene", 1:10)
#' rownames(mat2) <- paste0("Gene", 1:10)
#'
#' # Simulate weighted adjacency matrices
#' adjm1 <- matrix(runif(100), nrow = 10)
#' adjm2 <- matrix(runif(100), nrow = 10)
#' rownames(adjm1) <- colnames(adjm1) <- paste0("Gene", 1:10)
#' rownames(adjm2) <- colnames(adjm2) <- paste0("Gene", 1:10)
#'
#' # Threshold using cutoff_adjacency
#' bin_adjm_list <- cutoff_adjacency(
#'   count_matrices = list(mat1, mat2),
#'   weighted_adjm_list = list(adjm1, adjm2),
#'   n = 2,
#'   method = "GENIE3",
#'   quantile_threshold = 0.95,
#'   total_cores = 2,
#'   seed = 42,
#'   debug = TRUE
#' )
#'
#' # Check one binary adjacency matrix
#' bin_adjm_list[[1]]

cutoff_adjacency <- function(count_matrices, 
                             weighted_adjm_list, 
                             n, 
                             method = "GENIE3", 
                             quantile_threshold = 0.99,
                             weight_function = "mean", 
                             total_cores = BiocParallel::bpworkers(BiocParallel::bpparam()),
                             grnboost_modules = NULL,
                             seed = 123,
                             debug = FALSE) {
  
  method <- match.arg(method, choices = c("GENIE3", "GRNBoost2", "JRF"))
  weight_function <- match.fun(weight_function)
  
  if (length(count_matrices) != length(weighted_adjm_list)) {
    stop("Length of count_matrices must match weighted_adjm_list.")
  }
  
  # Prepare expression matrices
  count_matrices <- lapply(count_matrices, function(obj) {
    if (inherits(obj, "Seurat")) {
      as.matrix(Seurat::GetAssayData(obj, assay = "RNA", slot = "counts"))
    } else if (inherits(obj, "SingleCellExperiment")) {
      as.matrix(SummarizedExperiment::assay(obj, "counts"))
    } else {
      as.matrix(obj)
    }
  })
  
  shuffle_rows <- function(matrix, seed_vector) {
    shuffled <- matrix
    for (i in seq_len(nrow(matrix))) {
      set.seed(seed_vector[i])
      shuffled[i, ] <- sample(matrix[i, ])
    }
    shuffled
  }
  
  create_shuffled_matrices <- function(mat, n, base_seed) {
    lapply(seq_len(n), function(i) {
      seed_vector <- sample(base_seed + i + seq_len(nrow(mat)))
      shuffle_rows(mat, seed_vector)
    })
  }
  
  # Define total jobs (k matrices × n shuffles)
  job_list <- expand.grid(matrix_idx = seq_along(count_matrices), shuffle_idx = seq_len(n))
  job_list <- lapply(seq_len(nrow(job_list)), function(i) {
    list(matrix_idx = job_list$matrix_idx[i], shuffle_idx = job_list$shuffle_idx[i])
  })
  
  # Parallel strategy
  nCores_outer <- min(total_cores, length(job_list))
  nCores_inner <- max(floor(total_cores / nCores_outer), 1)
  
  param_outer <- if (method == "GRNBoost2") {
    BiocParallel::SerialParam()
  } else {
    BiocParallel::MulticoreParam(workers = nCores_outer, RNGseed = seed)
  }
  
  percentile_values_by_matrix <- vector("list", length(count_matrices))
  
  results <- BiocParallel::bplapply(job_list, function(job) {
    mat_idx <- job$matrix_idx
    shuf_idx <- job$shuffle_idx
    mat <- count_matrices[[mat_idx]]
    
    base_seed <- as.integer(round(seed * 1000 + mat_idx * 10 + shuf_idx))
    shuffled <- create_shuffled_matrices(mat, 1, base_seed)[[1]]
    
    args <- list(count_matrices_list = list(shuffled), method = method, adjm = NULL, seed = base_seed)
    
    if (method == "GENIE3") {
      args$total_cores <- nCores_inner
    }
    if (method == "GRNBoost2") {
      args$grnboost_modules <- grnboost_modules
      args$total_cores <- nCores_inner
    }
    
    inferred <- do.call(infer_networks, args)
    adjm <- generate_adjacency(inferred)
    symm <- symmetrize(adjm, weight_function = weight_function)[[1]]
    q_value <- quantile(symm[upper.tri(symm)], quantile_threshold, names = FALSE)
    list(matrix_idx = mat_idx, q_value = q_value)
  }, BPPARAM = param_outer)
  
  # Aggregate results by matrix
  for (res in results) {
    mat_idx <- res$matrix_idx
    percentile_values_by_matrix[[mat_idx]] <- c(percentile_values_by_matrix[[mat_idx]], res$q_value)
  }
  
  binary_adjm_list <- lapply(seq_along(weighted_adjm_list), function(idx) {
    avg_cutoff <- mean(percentile_values_by_matrix[[idx]])
    if (debug) message(sprintf("[Method: %s] Matrix %d → Cutoff = %.5f", method, idx, avg_cutoff))
    ifelse(weighted_adjm_list[[idx]] > avg_cutoff, 1, 0)
  })
  
  return(binary_adjm_list)
}
