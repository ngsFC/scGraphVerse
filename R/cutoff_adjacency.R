#' Apply Cutoff to Adjacency Matrices Based on Shuffled Network Percentiles
#'
#' This function thresholds weighted adjacency matrices by computing a cutoff based on 
#' the 99th percentile of edge weights obtained from shuffled versions of the input 
#' expression matrices. This approach helps distinguish significant regulatory interactions 
#' from random noise. The method supports different GRN inference algorithms.
#'
#' @param count_matrices A list of expression matrices (genes Ã— cells) or objects 
#'   coercible to matrices (e.g., \code{Seurat}, \code{SingleCellExperiment}). Each is used 
#'   to infer a regulatory network.
#' @param weighted_adjm_list A list of weighted adjacency matrices corresponding to 
#'   the networks inferred from \code{count_matrices}.
#' @param n Integer. Number of shuffled matrices to generate per original matrix 
#'   for estimating the background distribution.
#' @param method Character. Network inference method to use in shuffling-based estimation. 
#'   Options include \code{"GENIE3"}, \code{"GRNBoost2"}, or \code{"JRF"}.
#' @param weight_function Character or function. Function used to symmetrize adjacency 
#'   matrices. Common choices include \code{"mean"}, \code{"max"}, etc. Passed to \code{symmetrize()}.
#' @param nCores Integer. Number of processor cores to use for parallel computation. 
#'   Default is determined from the available BiocParallel workers.
#' @param grnboost_modules Optional argument passed only when \code{method = "GRNBoost2"}.
#'   Should be a list of gene modules used for GRNBoost2 inference. Default is \code{NULL}.
#'
#' @return A list of binary adjacency matrices (same dimension as \code{weighted_adjm_list}), 
#'   with edges set to 1 if their weight exceeds the estimated cutoff, and 0 otherwise.
#'
#' @details 
#' For each count matrix, \code{n} shuffled versions are generated by permuting 
#' rows independently. A network is inferred from each shuffled matrix, and the 
#' 99th percentile of upper-triangle weights is extracted. The average of these 
#' percentiles is used as the cutoff for the original weighted adjacency matrix.
#'
#' Parallel processing is used throughout via \pkg{BiocParallel}.
#'
#' @importFrom BiocParallel bplapply MulticoreParam bpworkers bpparam
#'
#' @export

cutoff_adjacency <- function(count_matrices, 
                             weighted_adjm_list, 
                             n, 
                             method = "GENIE3", 
                             weight_function = "mean", 
                             nCores = BiocParallel::bpworkers(BiocParallel::bpparam()) - 1,
                             grnboost_modules = NULL) {
  
  if (!is.list(count_matrices) || !is.list(weighted_adjm_list)) {
    stop("`count_matrices` and `weighted_adjm_list` must be lists.")
  }
  if (length(count_matrices) != length(weighted_adjm_list)) {
    stop("`count_matrices` and `weighted_adjm_list` must have the same length.")
  }
  
  # Ensure weight_function is a valid function
  weight_function <- match.fun(weight_function)
  
  # Coerce inputs to matrices (handle Seurat/SCE)
  count_matrices <- BiocParallel::bplapply(count_matrices, function(obj) {
    if (inherits(obj, "Seurat")) {
      return(as.matrix(t(Seurat::GetAssayData(obj, assay = "RNA", slot = "counts"))))
    } else if (inherits(obj, "SingleCellExperiment")) {
      return(as.matrix(t(SummarizedExperiment::assay(obj, "counts"))))
    } else {
      return(as.matrix(obj))
    }
  }, BPPARAM = BiocParallel::MulticoreParam(nCores))

  # Function to shuffle matrix rows with a seed vector
  shuffle_rows <- function(matrix, seed_vector) {
    shuffled_matrix <- matrix
    for (i in seq_len(nrow(matrix))) {
      set.seed(seed_vector[i])
      shuffled_matrix[i, ] <- sample(matrix[i, ])
    }
    return(shuffled_matrix)
  }

  # Generate shuffled matrices for one expression matrix
  create_shuffled_matrices <- function(original_matrix, n, base_seed = 1234) {
    BiocParallel::bplapply(seq_len(n), function(i) {
      seed_vector <- sample(base_seed + i + seq_len(nrow(original_matrix)))
      shuffle_rows(original_matrix, seed_vector)
    }, BPPARAM = BiocParallel::MulticoreParam(nCores))
  }

  # Main logic: for each count matrix
  binary_adjm_list <- BiocParallel::bplapply(seq_along(count_matrices), function(idx) {
    expr_mat <- count_matrices[[idx]]

    # Generate shuffled matrices
    shuffled_list <- create_shuffled_matrices(expr_mat, n, base_seed = 1000 + idx)

    # Infer networks from shuffled data
    percentile_values <- unlist(BiocParallel::bplapply(shuffled_list, function(shuf_mat) {
      if (method == "GRNBoost2") {
        inferred <- infer_networks(list(shuf_mat), method = method, nCores = 1, grnboost_modules = grnboost_modules)
      } else {
        inferred <- infer_networks(list(shuf_mat), method = method, nCores = 1)
      }
      adjm <- generate_adjacency(inferred)
      symm <- symmetrize(adjm, weight_function = weight_function)[[1]]
      weights <- symm[upper.tri(symm)]
      quantile(sort(weights, decreasing = TRUE), 0.99, names = FALSE)
    }, BPPARAM = BiocParallel::MulticoreParam(nCores)))

    # Apply average cutoff
    avg_cutoff <- mean(percentile_values)
    binary_mat <- ifelse(weighted_adjm_list[[idx]] > avg_cutoff, 1, 0)
    return(binary_mat)
  }, BPPARAM = BiocParallel::MulticoreParam(nCores))

  return(binary_adjm_list)
}

