#' Apply a cutoff to adjacency matrices based on shuffled network percentiles
#'
#' This function processes a list of count matrices and applies a cutoff to the adjacency 
#' matrices derived from weighted networks inferred using a specified method. The cutoff is 
#' calculated based on the 95th percentile of the weights from shuffled matrices. The function 
#' supports different network inference methods like GRNBoost2, GENIE3, and JRF.
#'
#' @param count_matrices A list of count matrices (expression data) used to infer networks.
#' @param weighted_adjm_list A list of precomputed weighted adjacency matrices for the count data.
#' @param n The number of shuffled matrices to generate for calculating percentiles.
#' @param method The method for network inference. It can be one of the following: 
#'   "GRNBoost2", "GENIE3", or "JRF".
#' @param weight_function The function used to symmetrize the adjacency matrices. Default is "mean".
#' @param nCores The number of cores to use for parallel computation. Default is the number of available cores.
#' 
#' @return A list of binary adjacency matrices (0s and 1s) for each count matrix. 
#'   The binary matrices are generated by applying the 95th percentile cutoff to the 
#'   weighted adjacency matrices.
#' 
#' @importFrom BiocParallel bplapply MulticoreParam
#' 
#' @export

library(BiocParallel)

cutoff_adjacency <- function(count_matrices, weighted_adjm_list, n, method = "GRNBoost2", 
                             weight_function = "mean", nCores = BiocParallel::bpworkers(BiocParallel::bpparam())) {
  
  if (!is.list(count_matrices) || !is.list(weighted_adjm_list)) {
    stop("count_matrices and weighted_adjm_list must be lists")
  }
  
  # Detect Seurat objects and extract expression matrices
  count_matrices <- BiocParallel::bplapply(count_matrices, function(obj) {
    if (inherits(obj, "Seurat")) {
      return(as.matrix(t(GetAssayData(obj, assay = "RNA", slot = "data"))))
    } else if (inherits(obj, "SingleCellExperiment")) {
      return(as.matrix(t(assay(obj, "logcounts"))))
    } else {
      return(as.matrix(obj))
    }
  }, BPPARAM = MulticoreParam(nCores))
  
  # Function to shuffle rows of a matrix
  shuffle_rows <- function(matrix, seed_vector) {
    shuffled_matrix <- matrix
    for (i in seq_len(nrow(matrix))) {
      set.seed(seed_vector[i])
      shuffled_matrix[i, ] <- sample(matrix[i, ])
    }
    return(shuffled_matrix)
  }
  
  # Generate shuffled matrices in parallel
  create_shuffled_matrices <- function(original_matrix, n) {
    BiocParallel::bplapply(seq_len(n), function(i) {
      seed_vector <- sample(1:10000, nrow(original_matrix))
      shuffle_rows(original_matrix, seed_vector)
    }, BPPARAM = MulticoreParam(nCores))
  }
  
  # Process each count matrix in parallel
  binary_adjm_list <- BiocParallel::bplapply(seq_along(count_matrices), function(mat_index) {
    original_matrix <- count_matrices[[mat_index]]
    
    # Generate shuffled matrices
    shuffled_matrices_list <- create_shuffled_matrices(original_matrix, n)
    
    percentile_values <- unlist(BiocParallel::bplapply(shuffled_matrices_list, function(shuffled_matrix) {
      network_results <- infer_networks(list(shuffled_matrix), method = method, nCores = nCores)
      network_results_adjm <- generate_adjacency(network_results)
      symmetric_network <- symmetrize(network_results_adjm, weight_function = weight_function)[[1]]
      ordered_weights <- sort(symmetric_network[upper.tri(symmetric_network)], decreasing = TRUE)
      quantile(ordered_weights, 0.95)
    }, BPPARAM = MulticoreParam(nCores)))
    
    mean_percentile <- mean(percentile_values)
    binary_adjm <- ifelse(weighted_adjm_list[[mat_index]] > mean_percentile, 1, 0)
    return(binary_adjm)
  }, BPPARAM = MulticoreParam(nCores))
  
  return(binary_adjm_list)
}

