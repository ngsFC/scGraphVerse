#' Threshold Adjacency Matrices Based on Shuffled Network Quantiles
#'
#' Applies a cutoff to weighted adjacency matrices using a percentile estimated
#' from shuffled versions of the original expression matrices. Supports inference methods
#' \code{"GENIE3"}, \code{"GRNBoost2"}, and \code{"JRF"}.
#'
#' @param count_matrices A list of expression matrices (genes Ã— cells) or \linkS4class{Seurat} or \linkS4class{SingleCellExperiment} objects.
#' @param weighted_adjm_list A list of weighted adjacency matrices (one per expression matrix) to threshold.
#' @param n Integer. Number of shuffled replicates generated per original expression matrix.
#' @param method Character string. One of \code{"GENIE3"}, \code{"GRNBoost2"}, or \code{"JRF"}.
#' @param quantile_threshold Numeric. The quantile used to define the cutoff. Default is \code{0.99}.
#' @param weight_function Character string or function used to symmetrize adjacency matrices (\code{"mean"}, \code{"max"}, etc.).
#' @param nCores Integer. Number of CPU cores to use for parallelization. Default is the number of workers in the current \pkg{BiocParallel} backend.
#' @param grnboost_modules Python modules needed for \code{GRNBoost2} if using reticulate.
#' @param debug Logical. If \code{TRUE}, prints detailed progress messages. Default is \code{FALSE}.
#'
#' @return
#' A list of binary (thresholded) adjacency matrices, each corresponding to an input weighted matrix.
#'
#' @details
#' For each input expression matrix, \code{n} shuffled versions are generated by randomly permuting each gene's expression across cells.
#' Network inference is performed on the shuffled matrices, and a cutoff is determined as the specified quantile (\code{quantile_threshold})
#' of the resulting edge weights. The original weighted adjacency matrices are then thresholded using these estimated cutoffs.
#'
#' Parallelization is handled via \pkg{BiocParallel}.
#'
#' The methods are based on:
#' \itemize{
#'   \item \strong{GENIE3}: Random Forest-based inference (Huynh-Thu et al., 2010).
#'   \item \strong{GRNBoost2}: Gradient boosting trees using arboreto (Moerman et al., 2019).
#'   \item \strong{JRF}: Joint Random Forests across multiple conditions (Petralia et al., 2015).
#' }
#'
#' @importFrom BiocParallel bplapply MulticoreParam SerialParam bpworkers bpparam
#' @importFrom Seurat GetAssayData
#' @importFrom SummarizedExperiment assay
#' @export
#'
#' @examples
#' set.seed(123)
#'
#' # Simulate two small expression matrices
#' mat1 <- matrix(rpois(100, lambda = 5), nrow = 10, ncol = 10)
#' mat2 <- matrix(rpois(100, lambda = 5), nrow = 10, ncol = 10)
#' rownames(mat1) <- paste0("Gene", 1:10)
#' rownames(mat2) <- paste0("Gene", 1:10)
#'
#' # Infer networks using GENIE3
#' network_list <- infer_networks(
#'   count_matrices_list = list(mat1, mat2),
#'   method = "GENIE3",
#'   nCores = 2
#' )
#'
#' # Convert inferred networks into adjacency matrices
#' list_wadj <- generate_adjacency(network_list)
#' list_swadj <- symmetrize(list_wadj, weight_function = "mean")
#'
#' # Apply cutoff based on shuffled quantiles
#' binary_adjm_list <- cutoff_adjacency(
#'   count_matrices = list(mat1, mat2),
#'   weighted_adjm_list = list_swadj,
#'   n = 2,
#'   method = "GENIE3",
#'   quantile_threshold = 0.95,
#'   nCores = 2,
#'   debug = TRUE
#' )
#'
#' # Inspect one thresholded adjacency matrix
#' binary_adjm_list[[1]]
cutoff_adjacency <- function(count_matrices,
                             weighted_adjm_list,
                             n,
                             method = "GENIE3",
                             quantile_threshold = 0.99,
                             weight_function = "mean",
                             nCores = 1,
                             grnboost_modules = NULL,
                             debug = FALSE) {
  method <- match.arg(method, c("GENIE3", "GRNBoost2", "JRF"))
  weight_function <- match.fun(weight_function)
  
  if (length(count_matrices) != length(weighted_adjm_list)) {
    stop("Length of count_matrices must match weighted_adjm_list.")
  }
  
  count_matrices <- .convert_counts_list(count_matrices)
  
  job_list <- expand.grid(matrix_idx = seq_along(count_matrices), shuffle_idx = seq_len(n))
  jobs <- lapply(seq_len(nrow(job_list)), function(i) {
    list(matrix_idx = job_list$matrix_idx[i], shuffle_idx = job_list$shuffle_idx[i])
  })
  
  param_outer <- if (method == "JRF") BiocParallel::SerialParam() else BiocParallel::MulticoreParam(workers = nCores)
  
  results <- BiocParallel::bplapply(jobs, function(job) {
    mat_idx <- job$matrix_idx
    mat <- count_matrices[[mat_idx]]
    q_value <- .run_network_on_shuffled(mat, method, grnboost_modules, weight_function, quantile_threshold)
    list(matrix_idx = mat_idx, q_value = q_value)
  }, BPPARAM = param_outer)
  
  cutoffs <- .aggregate_cutoffs(results, length(count_matrices))
  binary_list <- .binarize_adjacency(weighted_adjm_list, cutoffs, method, debug)
  return(binary_list)
}
