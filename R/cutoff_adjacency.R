#' Apply a cutoff to adjacency matrices based on shuffled network percentiles
#'
#' This function processes a list of count matrices and applies a cutoff to the adjacency 
#' matrices derived from weighted networks inferred using a specified method. The cutoff is 
#' calculated based on the 95th percentile of the weights from shuffled matrices. The function 
#' supports different network inference methods like GRNBoost2, GENIE3, and JRF.
#'
#' @param count_matrices A list of count matrices (expression data) used to infer networks.
#' @param weighted_adjm_list A list of precomputed weighted adjacency matrices for the count data.
#' @param n The number of shuffled matrices to generate for calculating percentiles.
#' @param method The method for network inference. It can be one of the following: 
#'   "GRNBoost2", "GENIE3", or "JRF".
#' @param weight_function The function used to symmetrize the adjacency matrices. Default is "mean".
#' @param nCores The number of cores to use for parallel computation (default is NULL for sequential).
#' 
#' @return A list of binary adjacency matrices (0s and 1s) for each count matrix. 
#'   The binary matrices are generated by applying the 95th percentile cutoff to the 
#'   weighted adjacency matrices.
#' 
#' @details 
#' This function generates shuffled matrices to calculate the 95th percentile of weights 
#' for each count matrix. Based on this, a cutoff is applied to the corresponding weighted 
#' adjacency matrix, converting the weights into binary values (1 for values greater than 
#' the 95th percentile, and 0 otherwise). The function handles different network inference 
#' methods, including "GRNBoost2", "GENIE3", and "JRF", and allows for parallel processing.
#'
#' @examples
#' \dontrun{
#' # Example usage of the cutoff_adjacency function
#' binary_adjm_list <- cutoff_adjacency(count_matrices = count_matrices,
#'                                      weighted_adjm_list = weighted_adjm_list,
#'                                      n = 100,
#'                                      method = "GRNBoost2",
#'                                      weight_function = "mean",
#'                                      nCores = 4)
#' }
#' 
#' @importFrom dplyr bind_rows
#' @importFrom pROC roc
#' 
#' @export
cutoff_adjacency <- function(count_matrices, weighted_adjm_list, n, method = "GRNBoost2", weight_function = "mean", nCores = NULL) {
  
  # Detect if count_matrices is a list of Seurat objects
  if (all(sapply(count_matrices, function(x) inherits(x, "Seurat")))) {
    message("Detected Seurat objects. Extracting expression matrices...")
    
    count_matrices <- lapply(count_matrices, function(obj) {
      GetAssayData(obj, assay = "RNA", layer = "data") # Extract expression data
    })
    
    count_matrices_list <- lapply(count_matrices, as.matrix) # Convert to matrix format
    count_matrices_list <- lapply(count_matrices_list, t) # Convert to matrix format
  }
  
  # Function to shuffle rows of a matrix
  shuffle_rows <- function(matrix, seed_vector) {
    shuffled_matrix <- matrix
    for (i in 1:nrow(matrix)) {
      set.seed(seed_vector[i])
      shuffled_matrix[i, ] <- sample(matrix[i, ])
    }
    return(shuffled_matrix)
  }
  
  # Function to create n shuffled matrices
  create_shuffled_matrices <- function(original_matrix, n) {
    shuffled_matrices <- list()
    for (i in 1:n) {
      seed_vector <- sample(1:10000, nrow(original_matrix))
      shuffled_matrix <- shuffle_rows(original_matrix, seed_vector)
      shuffled_matrices[[i]] <- shuffled_matrix
    }
    return(shuffled_matrices)
  }
  
  # Initialize list to store binary adjacency matrices
  binary_adjm_list <- list()
  
  # Main loop through count matrices
  for (mat_index in seq_along(count_matrices_list)) {
    original_matrix <- count_matrices_list[[mat_index]]
    
    # Initialize a list for storing 95th percentile values for this specific matrix
    all_percentile_values <- list()
    
    # Create shuffled matrices
    shuffled_matrices_list <- create_shuffled_matrices(original_matrix, n)
    
    if (method == "JRF") {
      jrf_mat <- infer_networks(shuffled_matrices_list, method = "JRF")
      jrf_list <- list()
      importance_columns <- grep("importance", names(jrf_mat[[1]]), value = TRUE)
      
      for (i in seq_along(importance_columns)) {
        df <- jrf_mat[[1]][, c("gene1", "gene2", importance_columns[i])]
        names(df)[3] <- importance_columns[i]
        jrf_list[[i]] <- df
      }
      
      # Generate adjacency matrices and calculate percentiles for each data frame in jrf_list
      for (k in seq_along(jrf_list)) {
        network_results_adjm <- generate_adjacency(list(jrf_list[[k]]))
        symmetric_network <- symmetrize(network_results_adjm, weight_function = weight_function)
        symmetric_network <- symmetric_network[[1]]
        
        # Extract and order weights from the upper triangle of the symmetric network
        upper_triangle_weights <- symmetric_network[upper.tri(symmetric_network)]
        ordered_weights <- sort(upper_triangle_weights, decreasing = TRUE)
        
        # Calculate the 95th percentile and add to the list
        percentile_95 <- quantile(ordered_weights, 0.95)
        all_percentile_values <- c(all_percentile_values, percentile_95)
      }
    } else {
      # For methods such as GENIE3 or GRNBoost2, process each shuffled matrix
      for (shuffled_matrix in shuffled_matrices_list) {
        network_results <- infer_networks(list(shuffled_matrix), method = method, nCores = nCores)
        
        network_results_adjm <- generate_adjacency(network_results)
        symmetric_network <- symmetrize(network_results_adjm, weight_function = weight_function)
        symmetric_network <- symmetric_network[[1]]
        
        # Extract and order weights from the upper triangle of the symmetric network
        upper_triangle_weights <- symmetric_network[upper.tri(symmetric_network)]
        ordered_weights <- sort(upper_triangle_weights, decreasing = TRUE)
        
        # Calculate the 95th percentile and add to the list
        percentile_95 <- quantile(ordered_weights, 0.95)
        all_percentile_values <- c(all_percentile_values, percentile_95)
      }
    }
    
    # Compute mean of 95th percentiles
    mean_percentile <- mean(unlist(all_percentile_values))
    
    # Apply cutoff to the corresponding weighted adjacency matrix
    weighted_adjm <- weighted_adjm_list[[mat_index]]
    binary_adjm <- ifelse(weighted_adjm > mean_percentile, 1, 0)
    binary_adjm_list[[mat_index]] <- binary_adjm
    
    # Print cutoff value for each matrix
    cat("Matrix", mat_index, "Mean 95th Percentile Cutoff:", mean_percentile, "\n")
  }
  
  return(binary_adjm_list)
}
