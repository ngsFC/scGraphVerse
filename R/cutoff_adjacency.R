#' Threshold Adjacency Matrices Based on Shuffled Network Quantiles
#'
#' Applies a cutoff to weighted adjacency matrices using a percentile estimated
#' from shuffled versions of the original expression matrices. Supports inference methods
#' \code{"GENIE3"}, \code{"GRNBoost2"}, and \code{"JRF"}.
#'
#' @param count_matrices A list of expression matrices (genes × cells) or \linkS4class{Seurat} or \linkS4class{SingleCellExperiment} objects.
#' @param weighted_adjm_list A list of weighted adjacency matrices (one per expression matrix) to threshold.
#' @param n Integer. Number of shuffled replicates generated per original expression matrix.
#' @param method Character string. One of \code{"GENIE3"}, \code{"GRNBoost2"}, or \code{"JRF"}.
#' @param quantile_threshold Numeric. The quantile used to define the cutoff. Default is \code{0.99}.
#' @param weight_function Character string or function used to symmetrize adjacency matrices (\code{"mean"}, \code{"max"}, etc.).
#' @param nCores Integer. Number of CPU cores to use for parallelization. Default is the number of workers in the current \pkg{BiocParallel} backend.
#' @param grnboost_modules Python modules needed for \code{GRNBoost2} if using reticulate.
#' @param debug Logical. If \code{TRUE}, prints detailed progress messages. Default is \code{FALSE}.
#'
#' @return
#' A list of binary (thresholded) adjacency matrices, each corresponding to an input weighted matrix.
#'
#' @details
#' For each input expression matrix, \code{n} shuffled versions are generated by randomly permuting each gene's expression across cells.
#' Network inference is performed on the shuffled matrices, and a cutoff is determined as the specified quantile (\code{quantile_threshold})
#' of the resulting edge weights. The original weighted adjacency matrices are then thresholded using these estimated cutoffs.
#'
#' Parallelization is handled via \pkg{BiocParallel}.
#'
#' The methods are based on:
#' \itemize{
#'   \item \strong{GENIE3}: Random Forest-based inference (Huynh-Thu et al., 2010).
#'   \item \strong{GRNBoost2}: Gradient boosting trees using arboreto (Moerman et al., 2019).
#'   \item \strong{JRF}: Joint Random Forests across multiple conditions (Petralia et al., 2015).
#' }
#'
#' @importFrom BiocParallel bplapply MulticoreParam SerialParam bpworkers bpparam
#' @importFrom Seurat GetAssayData
#' @importFrom SummarizedExperiment assay
#' @export
#'
#' @examples
#' set.seed(123)
#'
#' # Simulate two small expression matrices
#' mat1 <- matrix(rpois(100, lambda = 5), nrow = 10, ncol = 10)
#' mat2 <- matrix(rpois(100, lambda = 5), nrow = 10, ncol = 10)
#' rownames(mat1) <- paste0("Gene", 1:10)
#' rownames(mat2) <- paste0("Gene", 1:10)
#'
#' # Infer networks using GENIE3
#' network_list <- infer_networks(
#'   count_matrices_list = list(mat1, mat2),
#'   method = "GENIE3",
#'   nCores = 2
#' )
#'
#' # Convert inferred networks into adjacency matrices
#' list_wadj <- generate_adjacency(network_list)
#' list_swadj <- symmetrize(list_wadj, weight_function = "mean")
#'
#' # Apply cutoff based on shuffled quantiles
#' binary_adjm_list <- cutoff_adjacency(
#'   count_matrices = list(mat1, mat2),
#'   weighted_adjm_list = list_swadj,
#'   n = 2,
#'   method = "GENIE3",
#'   quantile_threshold = 0.95,
#'   nCores = 2,
#'   debug = TRUE
#' )
#'
#' # Inspect one thresholded adjacency matrix
#' binary_adjm_list[[1]]
cutoff_adjacency <- function(count_matrices,
                             weighted_adjm_list,
                             n,
                             method = "GENIE3",
                             quantile_threshold = 0.99,
                             weight_function = "mean",
                             nCores = BiocParallel::bpworkers(BiocParallel::bpparam()),
                             grnboost_modules = NULL,
                             debug = FALSE) {
  method <- match.arg(method, choices = c("GENIE3", "GRNBoost2", "JRF"))
  weight_function <- match.fun(weight_function)

  if (length(count_matrices) != length(weighted_adjm_list)) {
    stop("Length of count_matrices must match weighted_adjm_list.")
  }

  # Preprocess expression matrices
  count_matrices <- lapply(count_matrices, function(obj) {
    if (inherits(obj, "Seurat")) {
      as.matrix(Seurat::GetAssayData(obj, assay = "RNA", slot = "counts"))
    } else if (inherits(obj, "SingleCellExperiment")) {
      as.matrix(SummarizedExperiment::assay(obj, "counts"))
    } else {
      as.matrix(obj)
    }
  })

  # Function to shuffle rows independently
  shuffle_rows <- function(matrix) {
    shuffled <- matrix
    for (i in seq_len(nrow(matrix))) {
      shuffled[i, ] <- sample(matrix[i, ])
    }
    shuffled
  }

  # Define all shuffle jobs
  job_list <- expand.grid(matrix_idx = seq_along(count_matrices), shuffle_idx = seq_len(n))
  job_list <- lapply(seq_len(nrow(job_list)), function(i) {
    list(matrix_idx = job_list$matrix_idx[i], shuffle_idx = job_list$shuffle_idx[i])
  })

  # Parallel strategy
  param_outer <- if (method == "JRF") {
    BiocParallel::SerialParam() # Force serial when method is JRF
  } else {
    BiocParallel::MulticoreParam(workers = nCores)
  }

  # Infer networks on shuffled matrices
  results <- BiocParallel::bplapply(job_list, function(job) {
    mat_idx <- job$matrix_idx
    mat <- count_matrices[[mat_idx]]

    shuffled <- shuffle_rows(mat)

    args <- list(count_matrices_list = list(shuffled), method = method, adjm = NULL, grnboost_modules = grnboost_modules)

    inferred <- do.call(infer_networks, args)
    adjm <- generate_adjacency(inferred)

    symm <- symmetrize(adjm, weight_function = weight_function)[[1]]
    q_value <- quantile(symm[upper.tri(symm)], quantile_threshold, names = FALSE)

    list(matrix_idx = mat_idx, q_value = q_value)
  }, BPPARAM = param_outer)

  # Aggregate quantile thresholds
  percentile_values_by_matrix <- vector("list", length(count_matrices))
  for (res in results) {
    mat_idx <- res$matrix_idx
    percentile_values_by_matrix[[mat_idx]] <- c(percentile_values_by_matrix[[mat_idx]], res$q_value)
  }

  # Apply thresholds to original weighted adjacency matrices
  binary_adjm_list <- lapply(seq_along(weighted_adjm_list), function(idx) {
    avg_cutoff <- mean(percentile_values_by_matrix[[idx]])
    if (debug) message(sprintf("[Method: %s] Matrix %d → Cutoff = %.5f", method, idx, avg_cutoff))
    ifelse(weighted_adjm_list[[idx]] > avg_cutoff, 1, 0)
  })

  return(binary_adjm_list)
}
